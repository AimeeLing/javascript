一.定时器
    1.setInterval
        1.定时器里的this是window;
        2.用bind改this;
    2.setTimeout
        1.定时器里的this是window;
        2.用bind改this;
    3.定时器返回值
        定时器的返回值是是一个数字(从数字1开始,到(1+),代表当前定时器是页面中的第几个定时器;(按照去银行办业务领取的排队号理解)
    4.清除定时器
        clearInterval/clearTimeout([NUM]): 通过定时器的排队号清除指定的定时器,而且不管用哪个定时器设置的,任意一个清除方法,只要把排队号指定好,都可以把定时器清除掉,比如: 用setInterval设置的的定时器,使用clearTimeout也可以把其清除掉(不推荐这样用);

二.同步和异步编程(JS中大部分操作都是同步编程)
    每当执行一句或者一段JS代码,其实都是在完成一个任务(任务执行分为两种模式:1.自上而下;2.上面任务没完成,先一个任务也可以接着做;)
    1.同步编程: 上一个任务没有完成,下一个任务不能执行(可以理解为: 任务是自上而下逐一执行的);
    2.异步编程: 上一个任务没有彻底完成(完成一半),下一个任务先去执行,等把下面的任务完成后,才会返回头执行上面没有彻底完成的任务;

    =>JS是单线程的编程语言: 它脑子里只有一根弦,一次只能处理一件事;
    =>JS中大部分操作都是同步编程;

三.同步案例和异步编程案例

    1.同步编程案例
        //->能打印"No"?: 条件恒成立,死循环,不能打印"No";
        //->当前这个while循环是死循环,当前这件任务永远无法完成,而循环的操作是同步编程(这件事完不成,以后的事都无法完成)
            var n = 1;
            while (n === 1){
                console.log("Ok");
            }
            console.log("No");//->这个"No"永远不会被打印;如果"No"下有其他代码,其他代码也不会执行



    2.异步编程案例
        案例一: 定时器
            //->定时器时间是1s(1000)
            //->打印顺序: 先打印12,后打印13;原理如下:
                /*
                * 这个定时器的任务: 设置一个定时器,1s后执行匿名函数;
                * //->这个定时器如果按照同步理解: 首先设置一个定时器,然后等待,此时什么都不能做,1s后把函数执行,才能执行其他的任务;(这是错误的,这个定时器不是按照同步理解的;是按照异步理解);
                * //->这个定时器是按照异步理解: 首先设置定时器,但我们不会去等待到时间再去做其他事情,在这个阶段我们首先会把下面的任务逐一去完成,当下面任务完成后,我们再返回头看定时器的等待时间是否叨叨,到达则执行匿名函数,如果没到继续等待;(这个才是定时器的正确的理解思想);
                *
                * */
                var n = 12;
                setInterval(function () {
                    n++;
                    //console.log(n);//->2.再打印13;
                },1000);
                console.log(n);//->1.先打印12;










        案例二: 事件绑定









        案例一: AJAX



































































