一.DOM的映射机制
    1.在JS中获取的DOM元素或者元素集合,和HTML页面上的元素标签是存在"映射关系"的;
        1.JS中把DOM元素进行修改,页面中的元素样式也会跟着改变;
        2.页面中元素的结构发生改变,JS中的DOM元素也会跟着改变;

        源码范例:
        var stuList = document.getElementById("stuList"),
            stuBody = stuList.tBodies[0],
            stuRows = stuBody.rows;
            //->开始的时候页面中没有tr,所以stuRows是一个空的类数组;

        ~function () {
            //->1.getData获取数据
            ....

            //->bindData绑定数据
            var str = ``;
            ....
            stuBody.innerHTML = str;//->向页面中增加了20个tr
            console.log(stuRows);//->页面中tBody结构中的内容改变了,根据DOM的映射机制,此处不需要重新的获取,stuRows中存储的就是最新的20条数据;
        }();

二.sortTable案例
    考试时可以借用的文件:
        1.reset.min.css
        2.data.json

三.学习方法
    1.基础知识,一周三次过笔记
    2.所有课堂综合案例,理清思路,详细中文注释(伪代码)编写代码;

四.正则(只能处理字符串;不能处理对象...等其它)
    1.用来处理"字符串"的规则
        1.验证当前的字符串是否符合规则 - 匹配;
        2.把字符串中符合规则的字符捕获奥 - 捕获;
    2.正则匹配: [正则].test([字符串]);
    3.正则捕获: [正则].exec([字符串]);
        或者: [字符串].match([正则]);
        或者: [字符串].replace([正则],function....);
        或者: [字符串].split([正则]);
        或者....很多;

五.元字符/修饰符/正则的创建方式
    1.正则的创建方式
        1.字面量创建方式
            var reg = /^\d+$/g;
        2.实例(构造函数)创建方式
            var reg = new RegExp("[元字符]","[修饰符]");

        一个正则就是由元字符和修饰符组成的;
        想要学会编写自己所需的规则;
        需要牢牢掌握元字符和修饰符;

    2.正则的修饰符(img)
        1.i(ignoreCase): 忽略大小写匹配;
        2.m(multiline): 多行匹配;
        3.g(global): 全局匹配;
        4.修饰符在正则中放置的位置
            1.修饰符放在最后一个斜杠的后面
                var reg = /^\d+$/img;
            2.实例创建方式中,修饰符放在第二个实参字符串中;第一个实参字符串放的是元字符;
                var reg = new RegExp("元字符","img");

    3.正则的元字符
        //->两个斜杠中间包起来的都是正则的元字符;教材第三页"元字符列表",背吧!!!常用的元字符(一二十个)
        元字符分类:
            1.特殊元字符: 有特殊含义的元字符;
            2.量词元字符: 代表出现多少次的元字符;
            3.普通元字符: 代表普通含义的元字符;

        1.特殊元字符: 有特殊含义的
            1.\: 转义字符;就是把普通元字符转换为特殊的意义或者把特殊元字符转换为普通的意义;
                例如: /\d/ d本身就是一个字母,前面加一个转义字符,代表0-9之间的一个数字;
                    或者/\./ 点在正则中代表任意字符(特殊含义),此处加上转义字符,代表的就是本身意思点了;
            2.^(caret): 以某一个元字符开始;
                例如: /^1/ 代表当前字符串应该是以1开始的;
            3.$(dollar): 以某一个元字符结束;
                例如: /2$/ 代表当前字符串最后一个字符应该是以2结尾;
            4.\d: 代表一个(0-9)之间的数字;
            5.\D: 和\d正好相反,代表一个(非0-9)之间的任意字符;(大写字母都和小写字母的是相反的)
            6.\w: 数字,字母,下划线三者中的任意一个;
            7.\n: 匹配一个换行符;
            8.\b: 匹配一个边界;
            9.\s: 匹配一个空白字符
            10..(点): 除了\n以外的任意一个字符
            11.x|y: x或者y中的一个字符
            12.(): 分组;
            13.[a-z]: 匹配一个a-z中的任意字符;/[0-9]/ 0-9之间的任何一个数字,等价于\d;
            14.[^a-z]: 除了a-z以外的任意一个字符,这里是^是取反的意思;
            15.[xyz]: x或者y或者z,三者中的一个;
            16.[^xyz]: 除了三者以外的任意一个字符
            17.?=(问号等号): 正想预查
            18.?!(问号叹号): 负向预查
            19.?:(问号冒号): 只匹配不捕获;

        2.量词元字符: 代表出现多少次
            20.*(星号): 前面的元字符出现零次到多次;
            21.+(加号): 前面的元字符出现一次到多次;
            22.?(问号): 前面的元字符出现零次或者一次;
            23.{n}: 出现n次;
            24.{n,}: 出现n到多次;
            25.{n,m}: 出现n到m次;

        3.普通元字符: 代表本身含义的
            26.除了特殊和量词元字符之外的,都是普通元字符;

六.常用的正则表达式

    1.中括号的细节问题:
        1.中括号里面出现的多位数字,并不是多位数,而是数字中出现的任意一个;
            范例:
            var reg = /^[18]$/;//->1或者8中的一个数字
            var reg = /^[16-85]$/;//->1或者66-8或者5,三者中的一个数字;
        2.\w使用中括号的方式表达: 数字,字母,下划线
            范例:
            var reg = /^[0-9a-zA-Z_]$/;
        3.中括号中出现的元字符一般都是自己本身的意思(即使具备特殊的意思,很多元字符也都自动变为本身的意思了)
            范例:
            var reg = /^[+-.\d?]$/;//->除了\d依然代表的是0-9中的一个数字,其余的都是代表本身的意思


    2.小括号的一些作用和细节
        范例:
        var reg = /^18|19$/;
            //->按照我们本身的理解,应该是18或者19两个中的任意一个,符合x|y这个元字符的规则;
            //->但是显示不是这样的,上面的规则,18/19/181/189/119/819....都符合,它识别和处理的规则特别乱;
        var reg = /^(18|19)$/;
            //->当我们使用分组把它包起来的时候就好了,现在只能匹配18或者19了,其余的都不可以;


        总结:
            1.正则中分组"()"第一个作用: 改变默认的优先级;//->案例4: 验证是否为有效数字的
            2.正则分组的第二个作用是: 分组引用
                //->\1 或者 \2 或者 \数字
                    代表个对应分组出现一模一样的内容,也就是\1代表和第一个分组出现的内容一模一样;
                var reg = /^([a-z])([a-z])\2\1$/;//->OPPO   moom   toot....
            3.正则分组的第三个作用: 分组捕获
                案例5: 验证身份证号码

    3.案例:
        1.手机号码
            分析:
            1.以1开头
            2.11位数字
            var reg = /^1\d{10}$/;//->以1开头,连续出现10个数字;同时加了^和$,此正则可以理解为只能是某某某规则;
            //->如果^和$都不加,只要字符串当中有一部分符合这个规则即可;

        2.验证年龄
            1.在18-65岁之间;
            var reg = /^((18|19)|([2-5]\d)|(6[0-5]))$/;//->  \d: 0-9
                分析:
                //->18或者19
                //->20-59
                //->60-65
                //->分三个阶段完成操作
        3.验证中文姓名的
            var reg = /^[\u4e00-\u9fa5]{2,4}$/;
            分析: 只能是中文汉字;
                1.第一个汉字的ASCII码: \u4e00;
                2.最后一个汉字的ASCII码: \u9fa5;
                正常一般都是2-4位;
            var reg = /^[\u4e00-\u9fa5]{2,5}(·[\u4e00-\u9fa5]{2,5})?$/;
                //->支持: 大卫·贝克汉姆
·
        4.验证是否为有效数字的
            var reg = /^-?(\d|([1-9]\d+))(\.\d+)?$/;//->\d+: 1到多位数字;
            分析
                1.可能出现-,也可能不出现;
                2.一位数可以是零,多位数零不能作为开头;
                3.小数部分可能有可能没有,如果一旦有,小数点后面必须有数字;

        5.验证身份证号码的
            简单来写的方法: 前17位是数字,最后一位数字或者X
                var reg = /^\d{17}(\d|X)$/;//->130828(省市县)  1990(年) 12(月) 04(日) 06(随机) 1(性别) 7
                130828199012040617
            完善方法: 我们需要在身份证中获取到省市县,年月日,性别,等信息;以上写法太简单;
                var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(?:\d|X)$/;//->?:(问号冒号): 只匹配不捕获

七.正则的捕获
    1.exec: 可以实现正则的捕获,每一次执行exec只能捕获到一个匹配的结果,而且结果时一个数组//->案例1
        1.第一项: 当前正则捕获的内容(字符串)
        2.index: 当前正则捕获的起始索引;
        3.input: 当前操作的原始字符串;





    案例1:
        var reg = /\d+/;//->只要包含1到多个数字就可以;
        var str = "zhufeng2017peixun2018";
        reg.exec(str);//->["2017", index: 7, input: "zhufeng2017peixun2018"]  =>数组
        再执行一次,还是这样的结果....
        reg.exec(str);//->["2017", index: 7, input: "zhufeng2017peixun2018"]  =>数组

        发现问题:
            当前正则执行一次exec只能捕获一个匹配的内容,我执行两次exec,第二次捕获到的依然还是第一次的结果;不管执行多少次exec,捕获到的依然都是第一个.... =>这叫"正则捕获的懒惰行";引申出lastIndex....

        1.lastIndex
            reg.lastIndex: 下一次正则捕获的时候,在字符串中查找的开始位置索引;
            第一次查找之前,reg.lastIndex=0,也就是第一次是从字符串的开始位置查找的;所以找到的时2017
            第一次执行exec结束后,reg.lastIndex值还是0,所以第二次依然是从字符串的开始位置查找的,找到的当然还是2017
            ....

        2.解决正则的懒惰行:
            执行exec后,让reg.lastIndex值变为当前这一次捕获的结束位置,这样下一次捕获的时候,就可以接着继续查找了;(而不是从头开始了)
            我们只需要给正则加一个全局修饰符g,就可以在每一次执行exec后,自动修改它的reg.lastIndex

            var reg = /\d+/;
            var str = "zhufeng2017peixun2018";
            undefined
            reg.exec(str);
            ["2017", index: 7, input: "zhufeng2017peixun2018"]
            reg.lastIndex
            0
            var reg = /\d+/g;//->加g
                    var str = "zhufeng2017peixun2018";
            undefined
            reg.lastIndex
            0
            reg.exec(str);
            ["2017", index: 7, input: "zhufeng2017peixun2018"]
            reg.lastIndex
            11
            reg.exec(str);
            ["2018", index: 17, input: "zhufeng2017peixun2018"]
            reg.lastIndex
            21
            reg.exec(str);
            null
            reg.lastIndex
            0
            reg.exec(str);
            ["2017", index: 7, input: "zhufeng2017peixun2018"]
            reg.lastIndex
            11

            上面的案例中,我们知道执行量词就可以捕获全了,但是如果你不知道具体要捕获多少次,我们该如何是好?
            =>接下来我们自己在RegExp的原型上扩展一个方法myExecAll,执行这个方法,可以把所有匹配的一次性都捕获到;

        3.扩展的myExecAll捕获方法
            RegExp.prototype.myExecAll = function myExecAll(str){
                //->this: reg当前要操作的实例
                //->1.验证正则是否有加g(为了防止不加g的时候,每一次捕获的都是第一个,导致死循环,我们在正则没有加g的时候,执行一次即可;)
                if(!this.global){
                    //->没有加g,执行一次exec捕获即可;
                    return this.exec(str);
                }
                //->已经加g了
                var ary = [];//->存储所有捕获的结果
                while(res){
                    ary[ary.length] = res[0];//->res[0]: 数组中的第一项;把每一次捕获的结果存放在数组的末尾
                    res = this.exec(str);
                }
                return ary;
            }
            reg.myExecAll(str)//->str: 需要捕获的原始字符串

        4.字符串match实现正则exec捕获的方法
            字符串中有一个方法叫做match,执行这个方法,也可以把所有匹配的内容,一次性捕获到,但是前提正则也需要加g,不加g,也只能捕获第一个;
            var reg = /\d+/g;
            var str = "zhufeng2017peixun2018haha2019hehehe2020";
            str.match(reg);//->(4) ["2017", "2018", "2019", "2020"]


            match存在的问题:
                match虽然很简单暴力,但是在需要捕获小分组内容的时候,就不太符合我们的需求了,因为match它只能把大正则匹配捕获到,对于小分组匹配的无法捕获;
                范例:
                var ary = ["zxt",28];
                var str = "my name is {0},i am {1} years old~~";
                需求:
                1.我们想把{0} 替换成ary[0];
                2.我们想把{1} 替换成ary[1];
                3.我们纪要捕获到{数字},也需要把里面的数字单独的获取到(因为这个数字可以充当我们在数组中获取内容的索引);


                var reg = /^\{(\d+)\}$/g;//->大正则匹配的是"一个大括号中包含数字",第一个小分组匹配的是"大括号中的那个数字";

                reg.exec(str);//->["0", index: 12, input: "my name is {0},i am {1} years old~~"]
                 第一项大正则匹配的结果,第二项第一个分组匹配的结果,也就是使用exec可以捕获到小分组匹配的内容
                 reg.exec(str);//->["1", index: 21, input: "my name is {0},i am {1} years old~~"]

                 str.match(reg);//->(2) ["0", "1"]  使用match只能捕获到大正则匹配的,小分组匹配的获取不到;

                 match并不是所有情况下,都捕获不到分组的内容,当只需要捕获一次就可以完成的时候(或者不加g的时候),match获取的结果和exec一样
                 范例:
                    var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(?:\d|X)$/g;
                    身份证号码的正则:
                    var str = '130828199012040617';
                    str.match(reg);//->(6) ["130828199012040617", "130828", "1990", "12", "04", "1",
                     index: 0, input: "130828199012040617"]

             test在某些时候,也是实现捕获的: test匹配的时候,也是把符合的找到了,我们就可以使用一些特殊手段,把查找的内容取出来;


             var str = "my name is {0},i am {1} years old~~";
             var reg = /\{(\d+)\}/g;

             reg.test(str)
             console.log(RegExp.$1);//->0  获取第一次捕获的时候,第一分组中的内容($1);


             上面是正则捕获: 懒惰性,正则捕获还有一个特点: 贪婪性

             范例:
                var str = "zhufeng2017peixun2018haha2019hehehe2020";
                var reg = /\d+/g;

                reg.exec(str);//->["2017", index: 7, input:
                "zhufeng2017peixun2018haha2019hehehe2020"]  每次捕获的时候都是把当前蒸鹅匹配的最长结果捕获到  =>贪婪性

            取消贪婪性: 在量词元字符后面加一个问号就可以了
                var str = "zhufeng2017peixun2018haha2019hehehe2020";
                var reg = /\d+?/g;//->加个?问号
                reg.exec(str);
            问号的作用很多
                1.如果放一个非量词元字符的后面,它本身就是代表出现零次或者一次的量词元字符;
                2.如果出现量词元字符的后面,它本身是取消捕获时候的贪婪性的;
                var str = "zhufeng2017peixun2018";
                var reg = /\d+?/g;
                reg.exec(str);//["2", index: 7, input: "zhufeng2017peixun2018"]


没有分组捕获的时候用match
有分组捕获的时候用exec


作业:
    1.复习(第一周和第二周掌握不扎实的都要好好的复习)
        重点: 表格排序
    2.正则基础的复习

    3.预习
        正则第二周第三节课件7(replace),9,10,11(即将补课讲)
    4.补课19:30-21:30(2017.08.08-2017.08.09)
        1.下周二(补原型继承)
        2.下周三(数据类型检测)

预习:
    下周重点: JS盒子模型,图片延迟加载,DOM库;


将来:
     要封装26个方法,比如像previous一样;previous是26个方法中最简单的;





















