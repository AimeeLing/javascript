一.单利模式
    //->我们把描述东西特点特征的属性和方法汇总到一起,实现分组分类;避免了相互之间的冲突;我们把汇总在一起的那个对象,称之为一个单独的个体,或者是一个单独的实例 =>这种汇总的思想,就是"单利模式";
    var person1 = {
        name: "张三",
        age: 28
    };

    var person2 = {
        name: "李四",
        age: 30
    };


    1.单利模式
        //->person1和person2都是一个单独的个体(单独的实例),相互的name和age属性并不冲突,这就是基于"单利模式"的设计思想构造出来的
    2.命名空间
        //->person1或者person2不仅仅称之为对象名了,在单利模式下,它们称之为:"命名空间";
    3.单利模式
        把描述事务的属性和方法放在同一个命名空间下,实现分组分类的作用,避免了相互之间的冲突(全局变量的污染);
    4.项目中写单利模式(利用不销毁的作用域)--高级单利模式范例
        高级单利模式: 基于js高阶编程技巧"惰性函数思想"封装的单利模式
        var nameSpace = (function(){
            //->这里放js代码
            //->自执行函数执行形成一个不销毁的私有作用域(闭包);
            return{
                init: function(){
                    //->这里放js代码
                },
                name: "xxx",
                ...
            }
        })();
        nameSpace.init();
        //->单利模式是项目开发中做常用的设计模式之一,我们团队写作按模块化开发的时候,基本上都是基于单利的思想设计的,避免相互代码的冲突;
            //->按模块化开发: 把一个项目分配好几块之后下达给每一个人;  切页面  js效果  (公众方法/公众组件: 几十个项目经验才能做到这个地位)
    5.模拟百度开发
        百度首页按功能可以分为以下几个模块:
            1)频道页卡
            2)换肤
            3)天气
            4)登陆
            5....
            //->public
            //utils就是项目的公共方法库
            var utils = (function(){
                return {
                    cookie: function(){},
                    ...
                }
            })();


            A来做这个频道模块
            var channelModule = (function(){
                //->js代码
                return function(){
                    init: function(){....},
                    drag: function(){....},
                    ....
                }
            })();

            B来做换肤模块
            var changeSkinRender = (function(){
                //->js代码
                return function(){
                    init: function(){...},
                    change: function(){
                        channelModule.drag();
                        changeSkinRender.init();//->this.init()
                        utils.cookie();
                    },
                    ...
                }
            })();
            changeSkinRender.change();

二.工厂模式
    //->体现出了函数的封装特点: 把实现一个功能的代码进行封装,以后想实现这个功能,直接的执行函数即可,这样不仅仅实现了代码的"低耦合高内聚",而且实现了批量生产的快速开发=>"工厂模式";

三.面向对象编程思想(OOP)
    1.OOP: Object Oriented Programming
        Programming: 程序
        Object: 对象
        Oriented: 面向的
        面向过程(C是面向过程)/面向对象(大部分语言都是面向对象)
        //->学习自然界的过程就是面向对象;
    2.什么是面向对象,首先需要掌握三个概念
        1.对象: js中一切都是需要学习和研究的对象(不是对象数据类型;是泛指,是个抽象的名词);
        2.类: 对象的具体细分(例如: 自然界中分为植物类,动物类...每一个大类还可以分为小类...)
        3.实例: 每一个类别中具体的个体事物(例如: 小明就是人类中的一个实例);
    3.内置类
        js本身就是基于面向对象的思想构造出来的语言,所以js中肯定有很多的"内置类";
        1)每一种数据类型都有一个自己所属类的内置类,数据类型中的值,都是所属类的实例;
            Number: 每一个数字都是它的一个实例
            String: 每一个字符串都是它的一个实例
            Boolean
            Null
            Undefined
            Object
                Array: 数组类
                RegExp: 正则类
                Date: 日期类
                ...
            Function
            ...
        2)Array.prototype
            每一个数据类型所用的方法,都是当前所属类提前设定好的;实例就可以调取这些方法了;例如: Array数组类,数组为每一个实例设定了一些方法(Array.prototype在控制台输出这个方法,会出现很多的方法);
            以上这些方法就是数组给Array它的实例提供的,所以作为数组的实例,是可以调取这些方法使用的;
        3)元素或者节点集合类
            1.HTMLCollection: 元素集合类,通过DOM的方法获取到的元素集合都是它的实例;例如:
            getElementsByTagName/getElementsByClassName...
            2.Node List: 节点集合类,通过DOM方法获取到的节点集合都是它的一个实例;例如: getElementsByName/childNodes...
        4)DOM元素标签对应的内置类
            每一个元素标签都有一个自己对应的内置类;
            document.getElementsByClassName在控制台输出这个方法,会出现很多的实例;
            div: HTMLDivElement
            a: HTMLAnchorElement
            p: HTMLParagraphElement
        5)HTMLElement
        6)Element
        7)Node
        8)EvenTarget
        9)Object(这是个基类,暂时先略过...不讲;)

            具备面向对象的思想,而不是记知识点;实例之所以能使用一些方法,是因为当前的类里提供了一些这样的方法;
            学习面向对象,就要学习封装和多态;封装讲完了,以后会讲多态;
    以上1-8,都是内置类;

四.构造函数设计模式
    构造函数的作用: 基于面向对象的编程思想,创建js中的"自定义类";基于自定义的类,创建相关的实例...;

五.基于构造函数设计模式引申的原型模式
    //->原型是构造函数的引申,构造函数中公共属性部分就是由原型来掌控的
    以下三句话,就是规定:
        1.所有的函数数据类型
            //->普通函数
            //->类(构造函数)
            天生具备一个属性: prototype,这个属性的值是一个对象,当前类的公共属性和方法都在这个对象中存储着;
        2.prototype天生具备一个属性: constructor(构造函数),这个属性存储的值就是当前类(函数)本身;

        3.每一个对象数据类型
            //->普通对象{}
            //->数组和正则等
            //->类的实例
            //->函数也是对象
            也会天生自带一个属性: __proto__,这个属性存储的值是它对应的类的prototype属性的值;


            function Fn(){
                constructor: Fn
            }
            Fn.prototype = {

            };

            //->理解
            Fn = {
                prototype: {
                    constructor: Fn
                }
            }
            ...

六.思考题think
    (5).plus(3).minus(2)   =>6        minus: 减     plus: 加
    //->作业1.自己在Number的原型上扩展plus/minus,实现以上需求;
    //->作业2.重写数组的slice方法,实现和内置一模一样的功能;(要求: 不能使用数组任何内置方法)
        Array.prototype.mySlice = function(){};
            //->slice(n,m);
            //->slice(n);
            //->slice(0);
            //->slice();
            //->slice();//->如果n>m?
            //->slice();//->如果n或者m为负数??
            //->slice();//->如果n或者m是非有效数字怎么办?
            //->slice();//->如果n或者m是小数怎么办?
            //->slice();//->如果n或者m超过最大的索引怎么办?
            ........
    //->3.作业3.昨天留的作业
    //->4.预习视频
        第一周第二节6.7.8视频(复习原型)
    //->5.第二周课程
        周六一天的内容: 第二章第一节/第二节
            高难度: 第二章第一节1.2视频;
            其余的有时间看看,没时间拉到

        第三节: 正则,衷心建议好好的看看(当然也可以看教材);

        全日制: 周三考试,周六补考;
        周末班: 周六考试;







解决冲突的方法
1.闭包(2个作用)--有个弊端,所有的变量都是私有的,返回给全局,又成了全局的变量,又会产生冲突;
2.单利模式;好的设计模式之一;项目开发中最常用的设计模式;











20170730 第一周 周日的课程:
单利模式/工厂模式/面向对象/内置类/构造函数/实例/类/原型链第一阶段(函数名的三个角色)/原型链第二阶段(链式写法/数组去重完整版)"





















