浏览器性能优化: 堆栈内存的销毁问题
1.堆内存释放:
    如果有变量(/函数名)占用了堆内存的地址,那么当前的堆内存则不能释放;

    -Google
        如果当前堆内存没有被任何的东西所引用,当前的堆内存就没用了;浏览器会在空闲的时候清理掉这些没用的堆内存(仅仅是google浏览器的处理机制);
    -IE
        IE下的堆内存释放采用的是计数器机制,如果内存地址被一个变量(函数名)占用,计数器累加1,如果之前的某个占用被移除,计数器减1;
        但是很多时候,IE的计数器计数的时候总会出现问题,导致内存泄露;(这里涉及到IE的泄露问题)
        -高程3(最后几页有关于IE堆内存的释放问题-性能优化问题)

    var obj = {name: "珠峰及培训"};//->obj = xxxfff000;此时的obj把堆内存占用了

    obj = null;//->把obj赋值为null,obj就不占用堆内存了,浏览器在空闲的时候会销毁这个无用的堆内存;
    null: 叫空对象指针;也就是不指向任何堆内存;
    null: 叫空对象指针;也就是不指向任何堆内存;
    null: 叫空对象指针;也就是不指向任何堆内存;
    null: 叫空对象指针;也就是不指向任何堆内存;
    null: 叫空对象指针;也就是不指向任何堆内存;

2.栈内存释放(指的就是作用域的释放)_全局作用域_私有作用域
    全局作用域: 浏览器加载页面的时候形成全局作用域,在浏览器中,把当前页面关闭的时候,全局作用域销毁;
    -立即销毁
        私有作用域: 函数执的时候会形成私有作用域;一般情况下,函数执行完成,形成的这个私有作用域立即释放销毁;
    -不立即销毁
        特殊情况: 当私有作用域中的某一个东西(一般指的都是私有作用域中开辟的那个堆内存)被作用域以外的变量给占用了,当前的私有作用域(栈内存)就不能销毁了;这个私有作用域不小会,代表着它里面存储的私有变量也不会销毁了;
    -销毁与不销毁,就看它有没有被占用;


    找它的上级作用域,跟执行没关系,看它在哪定义的;

    -思考题1
        教材: 13页,fo思考题;


3.i++和++i的区别
    都是在自身基础上累加1,不同地方在于和其它值运算的时候,累加1在前还是在后;
    -i++: 先运算,再累加
    -++i: 先累加,再运算

    var i = 10;
    console.log(5+i++);//->先计算5+i,计算完成后再把i累加1; =>15   i=11;
    console.log(5+(i++));//->嘉盛括号也是先运算再累加;结果同上

    console.log(5+(++i));//->先让i裂甲1,把累加后的结果和5及逆行运算; i=11 =>16


    -思考题2
        var i = 4;
        var res = 5+(++i)+(i++)+(i++)+(++i);
        console.log(res,i);//29   i=8
        剖析:
        5+(4+1) =>10    i=4+1=5
                10+5=>15    i=5+1=6
                         15+6=>21   i=6+1=7
                                 21+8=>29   i=8
4.闭包的作用
    -你了解过闭包吗?(易车面试题)
    目前外界普遍认为"形成一个不销毁的私有作用域"才叫闭包;
    var fn = (function(){
       var n = 12;
       return function(){
           console.log(++n);
       }
    })();
    闭包的作用:
        1.保护里面的私有变量不受外界干扰(里面的变量和全局变量没关系,防止全局变量污染);
            例如: 我们封装类库或者组件插件的时候,为了防止和全局变量冲突,我们都使用闭包把代码包裹起来(jQuery就是这样处理的);
            ;(function(window,undefined){
                var fn = null;
                var jQuery = function(){
                    ... ...
                }//->jQuery = xxxfff000
                window.jQuery = window.$ = jQuery;//->给全局增加了一个jQuery的属性和$的属性,这样在外面就可以使用jQuery或者$了;
            })(window);
            var fn = undefined;//->和闭包中的fn没关系,防止了冲突和污染
            $();//->$ = xxxfff000
        2.可以形成一个不销毁的私有作用域,来存储一些值;
            选项卡 这么写:
            for (var i = 0; i < oList.length; i++) {
                oList[i].onclick = (function () {
                    return function (i) {
                        changeTab(i);
                    };
                })();

            或者这么写:
            for (var i = 0; i < oList.length; i++) {
                ~function (i) {
                    oList[i].onclick = function () {
                        changeTab(i);
                    }
                }(i);//->每一次循环把全局作用域下的i变量存储的值,当作实参传递给形参i(私有变量);
            }
4.思考题
    10.一下代码的功能是要实现为5个input按钮循环帮i的那个click点击事件,绑定完成后点击12345五个按钮分别会alert输出01234娶个字符.
    请问如下代码是否能实现?
    如果不能实现那么现在的效果是什么样的?
    应该做怎样的修改才能达到我们想要的效果,并说明原理?
    var oTab = document.getElementById("btnBox");
5.THIS
    this这个,是执行这个方法的主体;

    以下所有规律都是在非严格模式下生效
        1.自执行函数执行,函数中的THIS是window;
            ~function(){
                console.log(this);//->window
            }();
        2.给元素的事件绑定方法,当事件触发方法执行的时候,方法中的THIS是当前操作的元素
            oDiv.onclick = function(){
                console.log(this);//->oDiv
            }
        3.方法执行,看方法名前面是否有"点";有"点","点"前面是谁,THIS就是谁;没有"点",THIS就是window;
            function fn(){
                console.log(this);
            }
            var obj = {
                aa: fn
            };
            fn();//->THIS: window
            obj.aa();//->THIS: obj
6.综合题



    涉及到的知识点:
        1.自执行函数中的this是window
        2.变量提升,在没赋值的时候,值是undefined      undefined*2 //->NaN
        3.
