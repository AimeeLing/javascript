
1.变量提升(声明): declare
    在(!当前!)全局作用域下的js代码自上而下执行之前,浏览器首先会把当前作用域(window/私有作用域)中带var/function关键字的进行提前声明或定义;这种机制叫变量提升(预解释);
    1)带var关键字的只是提前的declare(声明);
    2)带function关键字的,declare和defined(定义)都提前完成了;

    只声明没定义,默认值是undefined;

    仅仅是在全局作用域下声明的变量相当于给全局对象window增加了一个属性(私有作用域是不具备这个特点);

    function中的var,只是一个字符,字符没意义;
    重点记住:是在当前作用域!!!
    重点记住:是在当前作用域!!!
    重点记住:是在当前作用域!!!

2.作用域
    1)函数执行的步骤:
        1.先形成一个新的私有作用域,供函数体中代码执行;
        2.给形参赋值;
        3.私有作用于下的预解释;
        4.私有作用于中的js代码自上而下执行;
        5.作用域释放与不释放;

    2)作用域[scope]
        -全局作用域
            浏览器打开时形成的;
        -私有作用域
            函数执行时形成的;

        -栈内存
            不管是全局的还是私有的作用域,都是提供js代码运行环境的,我们把作用域称之为栈内存;
        -堆内存
            所有的引用数据类型再定义的时候,都会开辟一个新的内存空间,来存储自己的值,我们把存储东西的内存空间称之为堆内存;

        -对象(键值对)
            对象再自己的堆内存中存储的是"键值对";
        -函数(代码字符串)
            函数再自己的堆内存中存储的是"代码字符串";

        -全局变量
            -在全局环境中定义的变量是全局变量;
            -除了私有变量,都是全局变量;
            -在哪儿都能用;
        -私有变量
            -函数的形参是私有作用域中的私有变量;
            -在私有作用域中声明过的[变量]或者[函数]都是私有的;
            -只能在自己的地盘能用;



    3)闭包
        1.函数执行形成一个私有的作用域(栈内存);
            1)形参赋值
            2)变量提升
            形参或者声明过的变量是私有的,否则不是私有的;

        2.私有的变量受到了保护,和外界的变量没有关系,不会受到任何的干扰,我们把函数这种保护机制叫做"闭包";


    4)作用域链
        在私有作用域中执行代码的时候,如果当前这个变量不是私有的变量,则向上一级查找,也不是上一级私有的,则继续向上查找,一直找到window,如果window下也没有,要么报错....我们把这种向上一层层查找的机制叫做"作用域链";


    5)如何查找当前作用域的上级作用域
        看当前函数是在哪定义的,那么它执行的上级作用域就是谁,和它在哪执行是没有关系;

















    知识点汇总:
    1.在变量提升阶段,如果当前这个名字已经声明过了,则不再新的声明,只需要重新的定义赋值即可(变量名和函数名如果相同也算是重复)
    2.自执行函数: 函数创建和函数执行都完成了(自执行函数不参与变量提升);遵循函数执行的5步骤!!!!
    3.全局下的属性    f = xxx;     g = xxx;   这不是声明,是全局window的属性;同一个名称a,window.a和window的变量a没有区别;
    4.[]==![]    []==false   0==0:TRUE
    5.自执行函数前面加一个分号是为了防止上面的函数结束不加分号,导致括号的执行顺序出现错误;
    6.自执行函数;(function(){})()   还有! + - ~
    7.判断条件成立进入判断体;(准则: 判断条件是否成立都会声明)(只有判断条件成立才会赋值,判断条件不成立,就不会赋值)
    8.不管条件是否成立,都要进行预解释(IF和FOR在ES5的机制下是不存在作用域概念的,ES6的机制下是块级作用域);
    9.不管是带VAR还是带FUNCTION,判断体(三个判断)中出现的内容,在变量提升阶段都仅仅是声明,没有定义;
    10.function fn....条件成立,进入到判断体中的第一件事就是先把函数定义了;
    11.条件不成立,进入不到判断体中,函数还是无法赋值的;
    12.匿名函数: 函数表达式(把函数当作一个值,赋值给一个变量或者某个元素的某个事件)
    13.变量提升: 只对=左边的进行变量提升,右边的是值,不进行提升的操作;
    14.只声明没赋值,值是undefined,undefined不能执行;Uncaught TypeError: fn is not a function(报错);
    15.创建函数的方法中,函数表达式方式使用的较多,(保证先创建再执行);而function方式的用的少;
    16.var a = 12;a输出变量存储的值;console.log(window.a);window.a输出WIN属性A的属性值;
    17.提前应用b会报错;(因为没有变量提升);Uncaught ReferenceError: b is not defined;当前这一行代码报错,后面的代码都不再执行了;
    18.b = 13;//->b不是变量,不是赋值,不能变量提升;它是window的一个属性名(前提: 在全局作用域下;在私有作用域下操作是不一样的);
    19.这里是window.b = 13;
    20.变量提升: var a; ->说明A是当前私有作用域的私有变量,和外面没有任何关系;
    21.看一个函数的返回值,只需要看函数体中是否有return,有return,return后是啥,返回值就是啥;没有return,默认返回值是undefined;
    22.return;(return后面没东西,返回值也是undefined;)
    23.sum()代表的是执行后的返回结果;  有return,return后面是是啥,返回的就是啥;return后面没有值;返回的是undefined;



























