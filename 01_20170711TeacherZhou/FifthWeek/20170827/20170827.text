一.事件代理(事件委托)
    事件代理: Event Delegation
        利用事件的冒泡传播机制,我们给最外层容器的事件行为绑定一个方法,里面后代元素的事件行为不再绑定任何方法;这样我们操作的是后代元素,也同样会传播到外层容器上,绑定的方法也会执行;在这个方法中我们通过判断事件源是谁,来做不同的操作;
        轮播图,选项卡,使用事件委托重新构建;(把之前一个个元素的点击事件绑定方法的操作,改写成事件代理的操作)
        1.利用事件委托重构选项卡
        代码如下:



        2.利用事件委托重构轮播图


        3.前两天的购物车,是事件委托;文件6.1.js

        4.多级菜单,利用事件委托完成


    事件代理在真实项目中经常被应用
        1.一个容器中很多后台元素都要给某个事件行为绑定方法,此时就可以使用事件代理来操作了
        2.类似于操作xxx做什么,其余的做什么这样的需求基本上也是用事件委托
        3.元素是动态绑定的,需要给新绑定元素的某些行为绑定方法,一般也用事件委托
        ...
        实际开发中,事件委托太常用了;性能也好;


二.DOM事件模型
    在之前的学习中,我们想要给一个元素的某个行为绑定方法,我们都是xxx.onxxx=function(){...};来操作的,除了这种绑定方式外,我们还有其它的绑定方式

    1.DOM0级事件绑定
        document.body.onclick=function(){}
        原理: 给当前元素的某个私有属性(事件对应的私有属性)赋值的操作,赋的值是一个函数,当后期我们触发相关行为后,浏览器自己会把之前赋值的那个函数执行(传递事件对象)

        1.只有在当前元素私有属性中出现的事件属性,我们才可以绑定方法,没出现的绑定不了(例如: DOMContentLoaded[DOM结构加载完成]事件在元素的私有属性中不存在,所以不能使用DOM0为其绑定方法)
            代码展示:
            document.body.onclick = function(){
                //->这样写可以的;
            };

            document.body.DOMContentLoaded = function(){
                //->这样写没用,因为私有属性中没有这个事件属性
            };

        2.为其私有属性赋值,只能赋值一个,也就是说,DOM0事件绑定,只能给当前元素的某个事件行为绑定一个方法,绑定多个方法,最后绑定的会把前面的替换掉,只有最后一个有用;
            代码展示:
            window.onload=function(){
                console.log("OK");
            };
            window.onload=function(){
                console.log("NO");
            };
            //->当页面中的资源文件都加载完成后,触发load事件,此时只能把最后一次绑定的方法执行;所以window.onload在同一个页面中我们最好使用一次;

    2.DOM2级事件绑定
    DOM2级事件绑定语法:
        EventTarget.prototype 在eventTarget原型上提供了一些方法
            [标准]
                addEventListener/removeEventListener
                绑定和移除绑定的方法
            [IE678]
                attachEvent/detachEvent
                绑定和移除绑定的方法


    DOM2级事件绑定原理:
        DOM2和DOM0不一样,用它做事件绑定,是给当前元素的某个事件行为开辟一个"事件池(事件队列)"[浏览器会自动开辟一个容器,把通过DOM2绑定的方法依次存储在事件池当中;],依托DOM2方式可以给当前元素的某个事件行为绑定多个不同的方法;当行为触发的时候,浏览器会把事件池中的方法按照绑定的顺序依次执行;而且方法中的this是当前操作的元素;
        事件池: 事件队列;任务队列;专业术语还是叫事件池


    DOM0级和DOM2级的区别:
        和DOM0: 私有属性赋值
        DOM2: 给当前的元素开辟一个事件池;

        1.DOM2可以给当前元素的某个行为绑定很多个不同的方法;
        2.很多事件行为,DOM0不能绑定;DOM2都可以绑定;例如: DOMContentLoaded
            代码展示
            //=>JQ中的ready原理
            //->ready使用的是DOMContentLoaded事件(当DOM(HTML)结构加载完成就会被触发执行)
            //->页面中可以使用多次: 因为它是基于DOM2事件绑定来实现的,此时可以绑定多个方法,执行一次ready相当于绑定一个方法;
            $(document).ready(function(){});


            //=>window.onload
            //->onload事件本身就是所有资源都加载完成才会执行;
            //->我们此处使用的是DOM0事件绑定,所以只能绑定一次,如果我们改为: window.addEventListener("load",function(){},false)这种方式,也可以在页面中使用多次;
                 window.onload和window.load的区别:
                    1.window.onload是DOM0级事件绑定
                        onload事件本身就是所有资源都加载完成才会执行;
                    2.window.load是改写后的DOM2级事件绑定
                        我们改为: window.addEventListener("load",function(){},false)这种方式,也可以在页面中使用多次;


            //=>DOMContentLoaded事件不支持IE低版本attachEvent方法的绑定,JQ的ready方法,在IE低版本浏览器中使用的是:
            document.onreadystatechange事件,当document.readyState==="complete"的时候触发回调函数执行


            //->JQ中提供的事件方法都是基于DOM2级事件绑定来完成的
            //->on
            //->click
            //->hover
            //->delegate



























