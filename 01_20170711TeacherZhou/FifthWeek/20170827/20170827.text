一.事件代理(事件委托)
    事件代理: Event Delegation
        利用事件的冒泡传播机制,我们给最外层容器的事件行为绑定一个方法,里面后代元素的事件行为不再绑定任何方法;这样我们操作的是后代元素,也同样会传播到外层容器上,绑定的方法也会执行;在这个方法中我们通过判断事件源是谁,来做不同的操作;
        轮播图,选项卡,使用事件委托重新构建;(把之前一个个元素的点击事件绑定方法的操作,改写成事件代理的操作)
        1.利用事件委托重构选项卡
        代码如下:



        2.利用事件委托重构轮播图


        3.前两天的购物车,是事件委托;文件6.1.js

        4.多级菜单,利用事件委托完成


    事件代理在真实项目中经常被应用
        1.一个容器中很多后台元素都要给某个事件行为绑定方法,此时就可以使用事件代理来操作了
        2.类似于操作xxx做什么,其余的做什么这样的需求基本上也是用事件委托
        3.元素是动态绑定的,需要给新绑定元素的某些行为绑定方法,一般也用事件委托
        ...
        实际开发中,事件委托太常用了;性能也好;


二.DOM事件模型
    在之前的学习中,我们想要给一个元素的某个行为绑定方法,我们都是xxx.onxxx=function(){...};来操作的,除了这种绑定方式外,我们还有其它的绑定方式

三.DOM0级事件绑定
    document.body.onclick=function(){}
    原理: 给当前元素的某个私有属性(事件对应的私有属性)赋值的操作,赋的值是一个函数,当后期我们触发相关行为后,浏览器自己会把之前赋值的那个函数执行(传递事件对象)

    1.只有在当前元素私有属性中出现的事件属性,我们才可以绑定方法,没出现的绑定不了(例如: DOMContentLoaded[DOM结构加载完成]事件在元素的私有属性中不存在,所以不能使用DOM0为其绑定方法)
        代码展示:
        document.body.onclick = function(){
            //->这样写可以的;
        };

        document.body.DOMContentLoaded = function(){
            //->这样写没用,因为私有属性中没有这个事件属性
        };

    2.为其私有属性赋值,只能赋值一个,也就是说,DOM0事件绑定,只能给当前元素的某个事件行为绑定一个方法,绑定多个方法,最后绑定的会把前面的替换掉,只有最后一个有用;
        代码展示:
        window.onload=function(){
            console.log("OK");
        };
        window.onload=function(){
            console.log("NO");
        };
        //->当页面中的资源文件都加载完成后,触发load事件,此时只能把最后一次绑定的方法执行;所以window.onload在同一个页面中我们最好使用一次;

四.DOM2级事件绑定
    DOM2级事件绑定语法:
        EventTarget.prototype 在eventTarget原型上提供了一些方法
            [标准]
                addEventListener/removeEventListener
                绑定和移除绑定的方法
            [IE678]
                attachEvent/detachEvent
                绑定和移除绑定的方法


五.DOM2级事件绑定原理:
    DOM2和DOM0不一样,用它做事件绑定,是给当前元素的某个事件行为开辟一个"事件池(事件队列)"[浏览器会自动开辟一个容器,把通过DOM2绑定的方法依次存储在事件池当中;],依托DOM2方式可以给当前元素的某个事件行为绑定多个不同的方法;当行为触发的时候,浏览器会把事件池中的方法按照绑定的顺序依次执行;而且方法中的this是当前操作的元素;
    事件池: 事件队列;任务队列;专业术语还是叫事件池


六.DOM0级和DOM2级的区别:
    和DOM0: 私有属性赋值
    DOM2: 给当前的元素开辟一个事件池;

    1.DOM2可以给当前元素的某个行为绑定很多个不同的方法;
    2.很多事件行为,DOM0不能绑定;DOM2都可以绑定;例如: DOMContentLoaded
        代码展示
        //=>JQ中的ready原理
        //->ready使用的是DOMContentLoaded事件(当DOM(HTML)结构加载完成就会被触发执行)
        //->页面中可以使用多次: 因为它是基于DOM2事件绑定来实现的,此时可以绑定多个方法,执行一次ready相当于绑定一个方法;
        $(document).ready(function(){});


        //=>window.onload
        //->onload事件本身就是所有资源都加载完成才会执行;
        //->我们此处使用的是DOM0事件绑定,所以只能绑定一次,如果我们改为: window.addEventListener("load",function(){},false)这种方式,也可以在页面中使用多次;
             window.onload和window.load的区别:
                1.window.onload是DOM0级事件绑定
                    onload事件本身就是所有资源都加载完成才会执行;
                2.window.load是改写后的DOM2级事件绑定
                    我们改为: window.addEventListener("load",function(){},false)这种方式,也可以在页面中使用多次;


        //=>DOMContentLoaded事件不支持IE低版本attachEvent方法的绑定,JQ的ready方法,在IE低版本浏览器中使用的是:
        document.onreadystatechange事件,当document.readyState==="complete"的时候触发回调函数执行


        //->JQ中提供的事件方法都是基于DOM2级事件绑定来完成的
        //->on
        //->click
        //->hover
        //->delegate

七.DOM2移除事件的绑定
    DOM2绑定是把方法放在指定的事件池中,移除绑定也是把方法从事件池中移除掉,移除的时候需要指定具体要移除哪个方法,所以在绑定的时候,我们一般都是绑定实名函数而不是匿名函数;
    范例:
        function fn(){}
        绑定事件(绑定实名函数)当一个方法不用移除的时候,可以不用实名函数;
        document.body.addEventListener("click",fn,false);
        移除事件(移除实名函数)
        document.body.removeEventListener("click",fn,false);

    DOM0不需要这样处理,因为DOM0要移除事件绑定只需要赋值为null即可
    范例:
        document.body.onclick = null;


八.DOM2的兼容处理
    DOM2事件绑定,标准浏览器和IE低版本浏览器中除了语法上的区别,还有其它方法的区别: 三个区别
        1.this问题
        [标准浏览器]
            执行事件池中绑定的方法,方法中的this是当前操作的元素;会给方法传递事件对象进来,事件对象中存在target等属性;
        [IE低版本]
            执行方法的时候,方法中的this是window而不是当前元素;事件对象也传递捡来了,但是传递进来的值和window.event一样(和标准浏览器中的事件对象是有区别的);

        2.重复问题
        [标准浏览器]
            如果我们绑定的方法重复了,浏览器不会把重复的方法添加到事件池中;
        [IE低版本]
            如果我们绑定的方法重复了,浏览器没有内置识别重复的机制,导致事件中有重复的方法,执行的时候,一个方法可能会被执行多次;

        3.顺序问题
        [标准浏览器]
            执行的顺序是按照绑定的顺序(事件池中方法排列的顺序: 标准浏览器中会把后面绑定的方法放在事件池的末尾)依次执行的
        [IE低版本]
            而且低版本浏览器中在绑定的方法过多的时候,不知道是由于向事件池中增加的时候顺序混乱了,还是执行的时候顺序混乱了,总之执行的顺序和绑定的顺序是没关系的;


        我们DOM2事件兼容处理,其实就是想把IE低版本浏览器中的机制,改变成为和标准浏览器一模一样的机制(只需要处理IE低版本浏览器即可,高版本或者标准浏览器不去做任何特殊处理,按照浏览器默认的机制来运行即可);


        IE低版本浏览器之所以出现这些问题,都是内置的事件池机制惹的祸,如果我们想让它和标准的机制一样,我们无法修改内置的东西;只能自己虚造出一个事件池,让虚造的事件池和标准的一样,让IE低版本浏览器走我们虚造的那个事件池;



        ---------------------------------------------------
        标准浏览器中
        1.自动去重
             如果我们绑定的方法重复了,浏览器不会把重复的方法添加到事件池中;
        2.顺序有秩
             执行的顺序是按照绑定的顺序(事件池中方法排列的顺序: 标准浏览器中会把后面绑定的方法放在事件池的末尾)依次执行的
        3.this是当前元素
             执行事件池中绑定的方法,方法中的this是当前操作的元素;会给方法传递事件对象进来

        IE678低版浏览器
        1.不自动去重
             浏览器不会自动去重,如果我们给当前元素的某个行为绑定多个重复的方法,那么绑定的所有重复方法都会被执行(在向事件池中存储方法的时候,低版本浏览器没有检测是否重复,所以导致这个结果)
        2.顺序错乱
             而且低版本浏览器中在绑定的方法过多的时候,不知道是由于向事件池中增加的时候顺序混乱了,还是执行的时候顺序混乱了,总之执行的顺序和绑定的顺序是没关系的;
        3.this是window
             执行方法的时候,方法中的this是window而不是当前元素;事件对象也传递捡来了,但是传递进来的值和window.event一样(和标准浏览器中的事件对象是有区别的);

九.on方法,off方法,run方法

    内置事件池的特点:
        如果我们把一个方法增加到内置事件池中,以后要触发这个行为,浏览器会帮助我们把这些方法执行;

    如果内置的事件池中只有一个方法,那么顺序和重复都是浮云;

    自己创建的容器中如果增加了很多方法,当我们触发元素相关行为的时候,这些方法"不执行",我们一个破容器和元素有啥关系啊!!!怎么可能会执行;!!!

        on: 把需要给元素事件绑定的那些方法放到我们自己的事件池中(容器中)
            ->验证是否重复

        off: 在自己的事件池(容器中)把某个方法移除掉即可;

        run: 获取到我们自己创建容器的所有方法,然后按照顺序依次执行

        移除的时候off,不能改变原来数组中的索引位置,防止执行fun的时候跳过某些函数
           ->我们移除的时候,设置当前项为null
        在下一次run执行的时候,我们遇到数组中这一项为null,不执行,而是在数组中移除掉即可;

十.事件库event.js

十一.myBind兼容处理





