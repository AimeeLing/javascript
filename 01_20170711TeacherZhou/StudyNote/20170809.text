----------------------------------------------------------------------------------面向对象汇总(开始)
一.OOP
    OOP(Object Oriented Programming)面向对象编程
    需要掌握:
    1.类的继承,封装,和多态;
        1.封装
            把实现一个功能的JS代码封装为一个函数,以后想实现这个功能,执行函数即可=>"低耦合,高内聚";
        2.多态;
            类具备多种形态: 1.重载;2.重写;
            1.重载:
                1.后台语言中的重载: 方法名相同,参数不同(参数的类型或者个数不一样),相当于两个不同的方法,通过传参的不一样,执行对应的方法;这是后台中的重载;
                    例如:
                        public void sum(int num1,int num2){
                        //->code....

                        }

                        public void sum(int num){
                            //->code...
                        }
                        sum(10,20);//->执行第一个sum
                        sum(10);//->执行第二个sum

                2.前端的JS中,不存在类似于后台这样的重载,JS中如果方法名相同,其中一个会把它相同的函数名都给覆盖掉,最后只保留一个,不管传递几个参数,都只执行这一个;如果一定要说有重载,那么JS中的重载就是,通过给一个方法传递不同的实参,在方法中我们判断传递的实参,来处理不同的事情(arguments);
                    举例:
                        function sum(num1,num2){
                            console.log(1);
                        }
                        function sum(num1){
                            console.log(2);
                            if(arguments.length>1){
                                num1+=100;
                            }else{
                                num1-=100;
                            };
                        }
                        sum(10,20);//->2
                        sum(10);//->2

                3.重写
                    讲重写之前,先讲继承;(在继承后,子类还可以把父类的属性和方法进行修改,这就是多态中的重写);
        3.继承
            所谓的继承,就是子类继承父类中属性和方法;在继承后,子类还可以把父类的属性和方法进行修改,这就是多态中的重写;
            1.call继承(重要程度: 四颗星;很重要,一定要掰开揉碎的学会call继承;)--只继承父类私有
                特点: 只能让子类的[实例]继承父类私有的属性和方法;
                原理: 在创建子类实例的时候,把父类当作普通函数执行,让函数中的this变为当前子类的实例(使用call修改的this),此时在父类函数体中写的this.xxx
                = xxx这些私有的属性和方法,都被子类的实例所占有了;
                举例:(1.1.js)
                    ......

                弊端: 只能继承父类私有的;

            2.原型继承(重要程度: 五颗星;很重要,跟call继承一样,也要掰开揉碎的熟练掌握)--继承了父类私有和公有
                实现了: 父类私有的属性和公有的属性方法都被子类继承了,而且都变成子类[实例]公有的属性和方法;
                原理: 让子类的原型等于父类的一个实例(而父类的实例能够拥有父类私有和公有的属性和方法);这样子类的[实例]也同时拥有父类私有和公有的;但是原型继承和遗传不太一样,遗传是把父母的基因克隆一份到自己的身上(比如:call继承),而原型继承仅仅是让子类和父类直接建立了原型链的连接通道,子类[实例]所使用的父类公共方法,依然在父类的原型上,使用的时候只是通过原型链的查找机制查找到的(一定要记好了);
                举例: (1.2.js)
                    ....
                思考题:
                    //->有三个类
                    function A(){}
                    A.prototype.getA = function(){};
                    function B(){}
                    function C(){}


                    //->让C同时具备A和B的私有属性以及公有属性?

                弊端: 不管父类私有的还是公有的,都是子类公有的了;

            3.冒充对象继承(重要程度: 一颗星)
                特点: 以后使用for...in循环遍历对象的时候,为了防止遍历那些公有的属性和方法,所以我们写这个循环都这样写;
                    for(var key in obj){
                        if(obj.hasOwnProperty(key)){
                            //->code....

                        }
                    }
                    知识点:
                    1.for...in循环既可以遍历私有的属性和方法,也可以遍历[部分: 可枚举的都可以,不可枚举的不可以遍历]原型链上的属性和方法;
                    2.for循环不能遍历公有的属性和方法;
                原理:把父类的实例当作一个普通的对象,遍历循环,把父类的私有或者公有的属性和方法,可以放在子类的任意位置,随你喜好即可; =>一般不用;
                举例:(1.3.js)
                    ....

                弊端:

            4.组合继承(重要程度: 五颗星)
                原理: call继承 + 原型继承
                举例:
                    ...

                弊端: 对于父类私有的,在子类私有和公有上各有一份,有点重复;

            5.寄生组合式继承(重要程度: 六颗星)
                特点:
                原理: 它是把传统组合式继承中,父类私有的在子类私有和公有上各有一份,这个瑕疵点完善了一下而已;
                弊端: 父类私有的 =>子类私有的(遗传式: 把私有克隆一份过来的);父类公有的 => 子类公有的(非遗传式: 让原型链之间建立连接的通道)
                关于Object.create属性方法:
                第一步: 创建一个新的空对象
                第二步: 让新创建的这个对象的__proto__指向Object

            6.ES6中的继承
                原理: 采用的原理就是"寄生组合式继承"
                举例:
                    ....

            7.周氏继承法(专业名词: 中间类继承法)
                特点:
                原理:
                举例:
                    function sum(){
                        arguments.__proto__之前指向的是Object.prototype,不能使用数组中的方法;
                        arguments.__proto__ = Array.prototype;
                        //->arguments.__proto__指向Array.prototype,现在就可以使用数组中的方法了
                        //->Array.prototype.__proto__指向的是Object.prototype



                        //var ary = [].slice.call(arguments);
                        //->排序,掐头去尾求和,求平均....等等;
                        arguments.sort(function(a,b){return a-b;})
                        arguments.pop();
                        arguments.shift();
                        ....

                    };
                    sum(12,23,34,13,24,25);

                弊端: 不兼容IE;因为使用了__proto__;

----------------------------------------------------------------------------------面向对象汇总(结束)

二.复习正则
    正则的创建有两种方式
        1.字面量
            var reg = /^$/img;
        2.实例创建
            var reg = new RegExp("^$","img");
            有时候必须要用第二种
            举例:
            var str = "zhufeng";
            需求: 创建一个正则,正则的规则是str变量存储的值;在这个值的左右两边各有一个@符;例如:var reg = /@zhufeng@/;//->如果str存储的值变为"peixun"了,我们正则中的zhufeng,也应该是peixun;

            var reg = new RegExp("@"+str+"@");//->实例创建方式,第一个参数是一个存放元字符的字符串,我们则可以使用字符串拼接把一个变量的值[动态]设为正则的规则;

            var reg = /@"+str+"@/;//->让第一个引号出现1到多次,让r也出现1到多次...正则本身就不是字符串,何谈字符串拼接; =>字面量创建方式中,斜杠包起来的所有字符都是元字符;

            在使用实例创建的时候,我们在字符串中出现的元字符,有一些比较特殊,\d不是0-9之间的数字,我们应该写成\\d才可以;(第一个斜杠把第二个斜杠变成转译字符)

三.正则实战: 正则的另一个捕获方式 replace
    1.replace
        str.replace: 替换;
        需求:


    2.面试题
        需求: 当前字符串中哪一个字符出现的次数最多,出现了多少次;
        var str = "hello,my name is tom,i am 25 years old, i come from mars!";


    3.模板引擎实现的原理
        需求:
        var str = "my name is {0}, i am {1} years old, i can {2}.";
        var ary = ["zxt",28,"js"];
        替换: replace

        str = str.replace(/\{(\d+)\}/g,function(){
            arguments
        });

    4.
        需求: 所有单词的首字母大写
        var str = "hello,my name is tom, i am 25 years old,i come from mars!";


    5.思考题
        1.时间字符串格式化
        var str = "2017-8-9 16:43:5";
        //->把这个字符串可以变为"xxx年xx月xx日 xx时xx分xx秒" / "xx-xx xx:xx 08-09 16:43" ...变为一切你想需要的格式

        2.URL参数格式化
        var url = "http://www.zhufengpeixun.com/index.html?name=zxt&age=28&sex=1&type=0";
        //->问号以后的都是"URL问号传参值",接下来我们要把问号后面的信息拆解成为对象的键值对;
        //->{name:"zxt",age:28,sex:1,type:0}




































中括号的细节问题--抄三遍