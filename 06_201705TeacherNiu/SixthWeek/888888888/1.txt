第5版把在非严格模式下运行时的保留字缩减为下列这些:
class
const
enum
export
extends
import
super
在严格模式下,第5版还对以下保留字施加了限制:
implements
package
public
interface
private
static
let
protected
yield
注意,let和yield是第5版新增的保留字;其他保留字都是第3版定义的.为了最大程度地保证兼容性,建议读者将第3版定义的保留字外加let和yield作为编程时的参考.
在实现ECMAScript3的JavaScript引擎中使用关键字作标识符,会导致"Identifier Expected"错误.而使用保留字作标识符可能会也可能不会导致相同的错误,具体取决于特定的引擎.
第5版对使用关键字和保留字的规则进行了少许修改.关键字和保留字仍然不能作为标识符使用,但现在可以用作对象的属性名.一般来说,最好都不要使用关键字和保留字作为标识符和属性名,以便与将来的ECMAScript版本兼容.
除了上面列出的保留字和关键字,ECMA-262第5版对eval和arguments还施加了限制.在严格模式下,这两个名字也不能作为标识符或属性名,否则会抛出错误.
3.3 变量
ECMAScript的变量是松散型的,所谓松散类型就是可以用来保存任何类型的数据.换句话说,每个变量仅仅是一个用于保存值的占位符而已.定义变量时要使用var操作符(注意var是一个关键字),后跟变量名(标识符),如下所示:
var message;
这行代码定义了一个名为message的变量,该变量可以用来保存任何值(像这样未经过初始化的变量,会保存一个特殊的值--undefined,相关内容将在3.4节讨论).ECMAScript也支持直接初始化变量,因此在定义变量的同时就可以设置变量的值,如下所示:
var message = "hi";
在此,变量message中保存了一个字符串值"hi".像这样初始化变量并不会把它标记为字符串类型;初始化的过程就是给变量赋一个值那么简单.因此,可以在修改变量值的同时修改值的类型,如下所示:
var message = "hi";
message = 100;//有效,但不推荐
在这个例子中,变量message一开始保存了一个字符串"hi",然后该值又被一个数字值100取代.虽然我们不建议修改变量所保存值的类型,但这种操作在ECMAScript中完全有效.
有一点必须注意,即用var操作符定义的比那辆将成为定义该变量的作用域中的局部变量.也就是说,如果在函数中使用var定义一个变量,那么这个变量在函数推出后就会被销毁,例如:
function test(){
    var message = "hi";//局部变量
}
test();
alert(message);//错误!
这里,变量message是在函数中使用var定义的.当函数被调用时,就会创建该变量并为其赋值.而在此之后,这个变量又会立即被销毁,因此例子中的下一行代码就会导致错误.不过,可以像下面这样省略var操作符,从而创建一个全局变量:
function test(){
message = "hi";//全局变量
}
test();
alert(message);//"hi"
这个例子省略了var操作符,因而message就成了全局变量.这样,只要调用过一次test()函数,这个Bain两就有了定义,就可以在函数外部的任何地方被访问到.
虽然省略var操作符可以定义全局变量,但这也不是我们推荐的做法.因为在局部作用域中定义的全局变量很难维护,而且如果有意地忽略了var操作符,也会由于相应变量不会马上就有定义而导致不必要的混乱.给未经声明的变量赋值在严格模式下会导致抛出ReferenceError错误.
可以使用一条语句定义多个Bain两,只要像下面这样把每个变量(初始化或不初始化均可)用逗号分隔开即可:
var message = "hi",found = false, age = 29;
这个例子定义并初始化了3个变量.同样由于ECMAScript是松散类型的,因而使用不同类型初始化变量的操作可以放在一条语句中来完成.虽然代码里换行和变量缩进不是必需的,但这样做可以提高可读性.
在严格模式下,不能定义名为eval或arguments的变量,否则会导致语法错误.
3.4 数据类型ECMAScript中有5种简单数据类型(也称为基本数据类型):Undefined/Null/Boolean/Number和String.还有1种复杂数据类型---Object,Object本质上是由一组无序的名值对组成的.ECMAScript不支持任何创建自定义的机制,而所有值最终都将是上述6种数据类型之一.乍一看,好像只有6种数据类型不足以表示所有数据;但是,由于ECMAScript数据类型具有动态性,因此的确没有再定义其他数据类型的必要了.
3.4.1 typeof操作符
鉴于ECMAScript是松散类型的,因此需要有一种手段来检测给定变量的数据类型---typeof就是负责提供这方面信息的操作符.对一个值使用typeof操作符可能返回下列某个字符串:
"undefined"---如果这个值未定义;
"boolean"---如果这个值是布尔值;
"string"---如果这个值是字符串;
"number"---如果这个值是数值;
"object"---如果这个值是对象或null;
"function"---如果这个值是函数;
下面是几个使用typeof操作符的例子:
var message = "some string";
alert(typeof message);//"string"
alert(typeof(message));//"string"
alert(typeof 95);//"number"
这几个例子说明,typeof操作符的操作数可以是变量(message),也可以是数值字面量.注意,typeof是一个操作符而不是函数,因此李子中的圆括号尽管可以使用,但不是必需的.
有些时候,typeof操作符会返回一些令人迷惑但技术上却正确的值.比如,调用typeof null会返回"object",因为特殊值null被认为是一个空的对象引用.SaFari 5及之前版本,Chrome7及之前版本在对正则表达式调用typeof操作符时会返回"function",而其他浏览器在这种情况下会返回"object".
从技术角度讲,函数在ECMAScript种时对象,不是一种数据类型.然而,函数也确实有一些特殊的属性,因此通过typeof操作符来区分函数和其他对象是有必要的.
3.4.2 Undefined类型
Undefined类型只有一个值,即特殊的undefined.在使用var声明变量但未对其加以初始化时,这个变量的值就是undefined,例如:
var message;
alert(message == undefined);//true
这个例子只声明了变量message,但未对其进行初始化.比较这个变量与undefined字面量,结果表明它们是相等的.这个例子与下面的例子是等价的:
var message = undefined;
alert(message == undefined); //true
这个例子使用undefined值显示初始化了变量message.但我们没有必要这么做,因为未经初始化的值默认就会取得undefined值.
一般而言,不存在需要显示地把一个变量设置undefined值的情况.字面值undefined的主要目的是用于比较,而ECMA-262第3版之前的版本中并没有规定这个值.第3版引入这个值是为了正式区分空对象指针与未经初始化的变量.
不过,包含undefined值的变量与尚未定义的变量还是不一样的.看看下面这个例子:
var message;//这个变量声明之后默认取得了undefined值
//下面这个变量并没有声明
//var age
alert(message);//"undefined"
alert(age);//产生错误
运行以上代码,第一个警告框会显示变量message的值,即"undefined".而第二个警告框---由于传递给alert()函数的是尚未声明的变量age---则会导致一个错误.对于尚未生命过的变量,只能执行一项操作,即使用typeof操作符检测其数据类型(对未经声明的变量调用delete不会导致错误,但这样没什么实际意义,而且在严格模式下确实会导致错误).
然而,令人困惑的是:对未初始化的变量执行typeof操作符会返回undefined值,而对未声明的变量执行typeof操作符同样也会返回undefined值.来看下面的例子:
var message;//这个变量声明之后默认取得了undefined值
//下面这个变量并没有声明
//var age;
alert(typeof message);//"undefined"
alert(typeof age);//"undefined"
结果表明,对未初始化和未声明的变量执行typeof操作符都返回了undefined值;这个结果有其逻辑上的合理性.因为虽然这两种变量从技术角度看有本质区别,但实际上无论对哪种变量也不可能执行真正的操作.
即便未初始化的变量会自动被赋予undefined值,但显示地初始化变量依然是明智的选择.如果能够做到这一点,那么当typeof操作符返回"undefined"值时,我们就知道被检测的变量还没有被声明,而不是尚未初始化.
3.4.3 Null类型
Null类型时第二个只有一个值的数据类型,这个特殊的值时null.从逻辑角度来看,null值表示一个空对象指针,而这也正是使用typeof操作符检测null值时会返回"object"的原因,如下面的例子所示:
var car = null;
alert(typeof car);//"object"
如果定义的变量准备在将来用于保存对象,那么最好将该变量初始化为null而不是其他值.这样一来,只要直接检查null值就可以知道相应的变量是否已经保存了要给对象的引用,如下面的例子所示:
if(car != null){
    //对car对象执行某些操作
}
实际上,undefined值时派生自null值的,因此ECMA-262规定对它们的相等性测试要返回true;
alert(null == undefined);//true
这里,位于null和undefined之间的相等操作符(==)总是返回true,不过要注意的是,这个操作符出于比较的目的会转换其操作数(本章后面将详细介绍相关内容).
尽管null和undefined有这样的关系,但它们的用途完全不同.如前所述,无论在什么情况下都没有必要把一个变量的值显示地设置为undefined,可是同样的规则对null却不适用.换句话说,只要意在保存对象的变量还没有真正保存对象,就应该明确地让该变量保存null值.这样做不仅可以体现null作为空对象指针的惯例,而且也有助于进一步区分null和undefined.
3.4.4 Boolean类型
Boolean类型是ECMAScript中使用得最多的一种类型,该类型只有两个字面值:true和false.这俩个值与数字值不是一回事,因此true不一定等于1,而false也不一定等于0.以下是为变量赋Boolean类型值的例子:
var found = true;
var lost = false;
需要注意的是,Boolean类型的字面值true和false是区分大小写的.也就是说,True和False(以及其他的混合大小写形式)都不是Boolean值,只是标识符.
虽然Boolean类型的字面值只有两个,但ECMAScript中所有类型的值都有与这两个Boolean值等价的值.要将一个值转换为其对应Boolean值,可以调用转换函数Boolean(),如下例所示:
var message = "Hello world!";
var messageAsBoolean = Boolean(message);
在这个例子中,字符串message被转换成了一个Boolean值,该值被保存在messageAsBoolean变量中.可以对任何数据类型的值调用Boolean()函数,而且总会返回一个Boolean值.至于返回的这个值是true还是false,取决于要转换值的数据类型及其实际值.下表给出了各种数据类型及其对应的转换规则.
数据类型                     转换为true的值                     转换为false的值
Boolean                      true                              false
String                       任何非空字符串                     ""(空字符串)
Number                       任何非零数字值(包括无穷大)          0和NaN(参见本章后面有关NaN的内容)
Object                       任何对象                           null
Undefined                    n/a                               undefined
这些转换规则对理解流控制语句(如if语句)自动执行相应的Boolean转换非常重要,请看下面的代码:
var message = "Hello world!";
if(message){
    alert("Value is true");
}
运行这个示例,就会显示一个警告框,因为字符串message被自动转换成对应的Boolean值(true).由于存在这种自动执行的Boolean转换,因此确切地知道在流控制语句中使用的是什么变量至关重要.错误地使用一个对象而不是一个Boolean值,就有可能彻底改变应用程序的流程.
3.4.5 Number类型
Number类型应该是ECMAScript中最令人关注的数据类型了,这种类型使用IEEE754格式来表示整数和浮点数值(浮点数值在某些语言中也被成为双精度数值).为支持各种数值类型,ECMA-262定义了不同的数值字面量格式.
最基本的数值字面量格式是十进制整数,十进制整数可以像下面这样直接在代码中输入:
var intNum = 55;//整数
除了以十进制表示外,整数还可以通过八进制(以8为基数)或十六进制(以16为基数)的字面值来表示.其中,八进制字面值的第一位必须是零(0),然后是八进制数字序列(0~7).如果字面值中的数值超出了范围,那么前导零将被忽略,后面的数值将被当作十进制数值解析.请看下面的例子:
var octalNum1 = 070;//八进制的56
var octalNum2 = 079;//无效的八进制数值---解析为79
var octalNum3 = 08;//无效的八进制数值---解析为8
八进制字面量在严格模式下是无效的,会导致支持JavaScript引擎抛出错误.
十六进制字面值的前两位必须是0x,后跟任何十六进制数字(0~9及A~F).其中,字幕A~F可以大写,也可以小写.如下面的例子所示:
var hexNum1 = 0xA;//十六进制的10
var hexNum2 = 0x1f;//十六进制的31
在进行算数计算时,所有以八进制和十六进制的数值最终都将被转换成十进制数值.
①n/a(或N/A),时not applicable的缩写,意思时"不适用".
鉴于JavaScript中保存数值的方式,可以保存正零(+0)和负零(-0).正零和负零被认为相等,但为了读者更好地理解上下文,这里特别做此说明.
1.浮点数值
所谓浮点数值,就是该数值中必须包含一个小数点,并且小数点后面必须至少有一位数字.虽然小数点前面可以没有整数,但我们不推荐这种写法.以下时浮点数值的几个例子:
var floatNum1 = 1.1;
var floatNum2 = 0.1;
var floatNum3 = .1;//有效,但不推荐
由于保存浮点数值需要的内存空间时保存整数值的两倍,因此ECMAScript会不失时机地将浮点数值转换为整数值.显然,如果小数点后面没有跟任何数字,那么这个数值就可以作为整数值来保存.同样地,如果浮点数值本身表示的就是一个整数(如1.0),那么该值也会被转换为整数,如下面的例子所示:
var floatNum1 = 1.;//小数点后面没有数字---解析为1
var floatNum2 = 10.0;//整数---解析为10
对于那些极大或极小的数值,可以用e表示法(即科学计数法)表示的浮点数值表示.用e表示法表示的数值等于e前面的数值诚意10的指数次幂.ECMAScript中e表示法的格式也是如此,即前面是一个数值(可以是整数也可以是浮点数),中间是一个大写或小写的字母E,后面是10的幂中的指数,该幂值将用来与前面的数相乘.下面是一个使用e表示法表示是数值的例子:
var floatNum = 3.125e7;//等于31250000
在这个例子中,使用e表示表示的变量floatNum的形式虽然简洁,但它的实际值则是31250000.在此,e表示法的实际含义就是"3.125乘以10的7次方".
也可以使用e表示法表示极小的数值,如0.00000000000000003,这个数值可以使用更简洁的3e-17表示.在默认情况下,ECMAScript会将那些小数点后面带有6个零以上的浮点数值转换为以e表示法表示的数值(例如,0.0000003会被转换成3e-7).
浮点数值的最高精确度是17位小数,但在进行算数计算时其精确度远远不如整数.例如,0.1加0.2的结果不是0.3,而是0.30000000000000004.这个小小的舍入误差会导致无法测试特定的浮点数值.例如:
if(a + b == 0.3){//不要做这样的测试!
    alert("You got 0.3.");
}
在这个例子中,我们测试的是两个数的和是不是等于0.3.如果这两个数是0.05和0.25,或者是0.15和0.15都不会有问题.而如前所属,如果这两个数是0.1和0.2,那么测试将无法通过.因此,永远不要测试某个特定的浮点数值.
关于浮点数值计算会产生舍入误差的问题,有一点需要明确: 这是使用基于IEEE754数值的浮点计算的通病,ECMAScript并非独此一家;其他使用相同数值格式的语言也存在这个问题.
2. 数值范围
由于内存的限制,ECMAScript并不能保证世界上所有的数值.ECMAScript能够表示的最小数值保存在Number.MIN_VALUE中----在大多数浏览器中,这个值是1.7976931348623157e+308.如果某次计算的结果得到了一个超出JavaScript数值范围的值,那么这个数值将被自动转换成特殊的Infinity值.具体来说,如果这个数值是负数,则会被转换成-Infinity(负无穷),如果这个数值是正数,则会被转换成Infinity(正无穷).
如上所述,如果某次计算返回了正或负的Infinity值,那么该值将无法继续参与下一次的计算,因为Infinity不是能够参与计算的数值.要想确定一个数值是不是有穷的(换句话说,是不是位于最小和最大的数值之间),可以使用isFinite()函数.这个啊还能输在参与位于最小与最大数值之间时会返回true,如下面的例子所示:
var result = Number.MAX_VALUE + Number.MAX_VALUE;
alert(isFinite(result));//false
尽管在计算中很少出现某些值超出表示范围的情况,但在执行极小或极大数值的计算时,检测监控这些值时可能的,也是必需的.
访问Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以得到负和正Infinity的值.可以想见,这两个属性中分别保存着-Infinity和Infinity.
3. NaN
NaN,即非数值(Not a Number)是一个特殊的数值,这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(hey昂就不会抛出错误了).例如,在其他编程语言中,任何数值除以0都会导致错误,从而停止代码执行.但在ECMAScript中,任何数值除以0会返回NaN,因此不会影响其他代码的执行.
NaN本身有两个非同寻常的特点.首先,任何涉及NaN的操作(例如NaN/10)都会返回NaN,这个特点在多步计算中有可能导致问题.其次,NaN与任何值都不想等,包括NaNcy本身.例如,下面的代码回返回false:
alert(NaN == NaN);//false
针对NaN的这两个特点,ECMAScript定义了isNaN()函数.这个函数接受一个参数,该参数可以是任何类型,而函数会帮我们确定这个参数是否"不是数值".isNaN()在接收到一个值后,会尝试将这个值转换为数值.某些不是数值的值会直接转换为数值,例如字符串"10"或Boolean值.而任何不能被转换为数值的值都会导致这个函数返回true.请看下面例子:
alert(isNaN(NaN));//true
alert(isNaN(10));//false(10是一个数值)
alert(isNaN("10"));//false(可以被转换成数值10)
alert(isNaN("blue"));//true(不能转换成数值)
alert(isNaN("true"));//false(可以被转换成数值1)
①原书如此,但实际上只有0除以0才会返回NaN,正数除以0返回Infinity,负数除以0返回-Infinity.
这个例子测试了5个不同的值.测试的第一个值是NaN本身,结果当然会返回true.然后分别测试了数值10和字符串"10",结果这两个测试都返回了false,因为前者本身就是数值,而后者可以被转换成数值.但是,字符串"blue"不能被转换成数值,因此函数返回了true.由于Boolean值true可以转换成数值1,因此函数返回false.
尽管有点不可思议,但isNaN()确实也适用于对象.在基于对象调用isNaN()函数时,会首先调用对象valueof()方法,然后确定该方法返回的值是否可以转换为数值.如果不能,则基于这个返回值再调用toString()方法,再测试返回值.而这个过程也是ECMAScript中内置函数和操作符的一般执行流程,更详细的内容请参见3.5节.
4. 数值转换
有3个函数可以把非数值转换为数值:Number()/parseInt()和parseFloat().第一个函数,即转型函数Number()可以用于任何数据类型,而另两个函数则专门用于把字符串转换成数值.这3个函数对于同样的输入会有返回不同的结果.
Number()函数的转换规则如下.
如果是Boolean值,true和false将分别被转换为1和0.
如果是数字值,只是简单的传入和返回.
如果是null值,返回0.
如果是undefined,返回NaN.
如果是字符串,遵循下列规则:
如果字符串中包含数字(包括前面带正号和负号的情况),则将其转换为十进制数值,即"1"会变成1,"123"会变成123,而"011"会变成11(注意: 前导的零被忽略了);
如果字符串中包含有效的浮点格式,如"1.1",则将其转换为对应的浮点数值(同样,也会忽略前导零);
如果字符串中包含有效的十六进制格式,例如"0xf",则将其转换为相同大小的十进制整数值;
如果字符串是空的(不包含任何字符),则将其转换为0;
如果字符串中包含除上述格式之外的字符,则将其转换为NaN.
如果是对象,则调用对象的valueOf()方法,然后依照前面的规则转换返回的值.如果转换的结果是NaN,则调用的对象的toString()方法,然后再次依照前面的规则转换返回的字符串值.
根据这么多的规则使用Number()把各种数据类型转换为数值确实有点复杂.下面还是给出几个具体的例子吧.
var num1 = Number("Hello world!");//NaN
var num2 = Number("");//0
var num3 = Number("000011");//11
var num4 = Number(true);//1
首先,字符串"Hello world!"会被转换为NaN,因为其中不包括任何有意义的数字值.空字符串会被转换为0.字符串"000011"会被转换为11,因为忽略了前导的零.最后,true值被转换为1.
一元加操作(3.5.1节将介绍)的操作与Number()函数相同.
由于Number()函数在转换字符串时比较复杂而且不够合理,因此在处理整数的时候更常用的时parseInt()函数.parseInt()函数在转换字符串时,更多的是看其是否符合数值模式.它会忽略字符串前面的空格,直至找到第一个非空格字符.如果第一个字符不是数字字符或者负号,parseInt()就会返回NaN;也就是说,用parseInt()转换空字符串会返回NaN(Number()空字符串返回0).如果第一个字符是数字字符,parseInt()会继续解析第二个字符,直到解析完所有后续字符或者遇到了一个非数字字符.例如,"1234blue"会被转换为1234,因为"blue"会被完全忽略.类似地,"22.5"会被转换为22,因为小数点并不是有效的数字字符.
如果字符串中的第一个字符是数字字符,parseInt()也能够识别出各种整数格式(即前面讨论的十进制,八进制和十六进制数).也就是说,如果字符串以"0x"开头且后跟数字字符,就会将其当作一个十六进制整数;如果字符串以"0"开头且后跟数字字符,则会将其当作一个八进制数来解析.
为了更好地理解parseInt()函数的转换规则,下面给出一些例子:
var num1 = parseInt("1234blue");//1234
var num2 = parseInt("");//NaN
var num3 = parseInt(0xA);//10(十六进制数)
var num4 = parseInt(22.5);//22
var num5 = parseInt(070);//56(八进制数)
var num6 = parseInt("70");//70(十进制数)
var num7 = parseInt("0xf");//15(十六进制数)
在使用parseInt()解析像八进制字面量的字符串时,ECMAScript 3和5存在分歧.例如:
//ECMAScript 3热内时56(八进制),ECMAScript 5认为时70(十进制)
var num = parseInt("070");
在ECMAScript 3 JavaScript引擎中,"070"被当成八进制字面量,因此转换后的值是十进制的56.而在ECMAScript 5 JavaScript引擎中,parseInt()已经不具有解析八进制的能力,因此前导的零会被认为无效,从而将这个值当成"70",结果就得到十进制的70.在ECMAScript 5中,即使是在非严格模式下也会如此.
为了消除在使用parseInt()函数时可能导致的上述困惑,可以为这个函数提供第二个参数: 转换时使用的基数(即多少进制);如果知道要解析的值是十六进制格式的字符串,那么制定基数16作为第二个参数,可以保证得到正确的结果,例如:
var num = parseInt("0xAF",16);//175
实际上,如果制定了16作为第二个参数,字符串可以不带前面的"0x",如下所示:
var num1 = parseInt("AF",16);//175
var num2 = parseInt("AF");//NaN
这个例子中的第一个转换成功了,而第二个则失败了.差别在于第一个转换传入了基数,明确告诉parseInt()要解析一个十六进制格式的字符串;而第二个转换发现第一个字符不是数字字符,因此就自动种植了.制定基数会影响到转换的输出结果.例如:
var num1 = parseInt("10",2);//2(按二进制解析)
var num2 = parseInt("10",8);//8(按八进制解析)
var num3 = parseInt("10",10);//10(按十进制解析)
var num4 = parseInt("10",16);//16(按十六进制解析)
不指定基数意味着让parseInt()决定如何解析输入的字符串,因此为了避免错误的解析,我们建议无论在什么情况下都明确指定基数.
多数情况下,我们要解析的都是十进制数值,因此始终将10作为第二个参数是非常必要的.
与parseInt()函数类型,parseFloat()也是从第一个字符(位置0)开始解析每个字符.而且也是一直解析到字符串末尾,或者解析到遇见一个无效的浮点数字字符串为止.也就是说,字符串中的第一个小数点是有效的,而第二个小数点就是无效的了,因此它后面的字符串将被忽略.举例来说,"22.34.5"将会被转换为22.34.
除了第一个小数点有效之外,parseFloat()与parseInt()的第二个区别在于它始终都会忽略前导的零.parseFloat()可以识别前面讨论过的所有浮点数值格式,也包括十进制整数格式.但十六进制个数的字符串则始终会被换成0.由于parseFloat()只解析十进制值,因此它没有用第二个参数制定基数的用法.最后还要注意一点:如果字符串包含的是一个可解析为整数的数(没有小数点,或者小数点后都是零),parseFloat()会返回整数.以下是使用parseFloat()转换数值的几个典型事例.
var num1 = parseFloat("1234blue");//1234(整数)
var num2 = parseFloat("0xA");//0
var num3 = parseFloat("22.5");//22.5
var num4 = parseFloat("22.34.5");//22.34
var num5 = parseFloat("0908.5");//908.5
var num6 = parseFloat("3.125e7");//31250000
3.4.6 String类型
String类型用于表示由零或多个16位Unicode字符组成的字符序列,即字符串.字符串可以由双引号("")或者单引号('')表示,因此下面两种字符串的写法都是有效的:
var firstName = "Nicholas";
var lastName = 'Zakas';
与PHP中的双引号和单引号会影响对字符串的解释方式不同,ECMAScript中的这两种语法形式没有什么区别.用双引号白哦是的字符串和用单引号表示的字符串完全相同.不过,以双引号开头的字符串也必须以双引号结尾,而以单引号开头的字符串必须以单引号结尾.例如,虾米那这种字符串表示法会导致语法错误:
var firstName = 'Nicholas";//语法错误(左右引号必须匹配)
1.字符字面量
String数据类型包含一些特殊的字符字面量,也叫转移序列,用于表示非打印字符,或者具有其他用途的字符串.这些字符字面量如下表所示:
字面量            含义
\n                换行
\t                制表
\b                空格
\r                回车
\f                进纸
\\                斜杠
\'                单引号('),在用单引号表示的字符串中使用.例如: 'He said,\'hey.\''
\"                双引号("),在用双引号表示的字符串中使用.例如: "He said,\hey.\""
\xnn              以十六进制代码nn表示的一个字符(其中n为0~F).例如:,\x41表示"A"
\unnnn            以十六进制代码nnnn表示的一个Unicode字符(其中n为0~F).例如,\u03a3表示希腊字符;
这些字符字面量可以出现在字符串中的任意位置,而且也将被作为一个字符串来解析,如下面的例子所示:
var text = "This is the letter sigma: \u03a3.";
这个例子中的变量text有28个字符,其中6个字符长的转译序列表示1个字符.
任何字符串的长度都可以通过访问其length属性取得,例如:
alert(text.length);//输出28
这个属性返回的字符数包括16位字符的数目.如果字符串中包含双节字符,那么length属性可能不会精确地返回字符串中的字符数目.
2.字符串的特点
ECMAScript中的字符串是不可变的,也就是说,字符串一旦创建,它们的值就不能改变.要改变某个Bain两保存的字符串,首先要销毁原来的字符串,然后再用另一个包含新值的字符串填充该变量,例如:
var lang = "Java";
lang = lang + "Script";
以上示例中的变量lang开始时包含字符串"Java".而第二行代码把lang的值重新定义为"Java"与"Script"的组合,即"JavaScript".实现这个操作的过程如下:首先创建一个能容纳10个字符的新字符串,然后在这个字符串中填充"Java"和"Script",最后一步时销毁原来的字符串"Java"和字符串"Script",因为这两个字符串已经没用了.这个过程时在后台发生的,而这也是某些旧版本的浏览器(例如版本低于1.0的Firefox,IE6等)中拼接字符串时速度很慢的原因所在.但这些浏览器后来的版本已经解决了这个低效率的问题.
3.转换为字符串
要把一个值转换为一个字符串有两种方式.第一种时使用几乎每个值都有的toString()方法(第5章将讨论这个方法的特点).这个方法唯一要做的就是返回相应值的字符串表现.来看下面的例子:
var age = 11;
var ageAsString = age.toString();//字符串"11"
var found = true;
var foundAsString = found.toString();//字符串"true"
数值/布尔值/对象和字符串(没错,每个字符串也都有一个toString()方法,该方法返回字符串的一个副本)都有toString()方法.但null和undefined值没有这个方法.
多数情况下,调用toString()方法不必传递参数.但是,在调用数值的toString()方法时,可以传递一个参数:输出数值的基数.默认情况下,toString()方法以十进制格式返回数值的字符串表示.而通过传递基数,toString()可以输出以二进制,八进制,十六进制,乃至其他任意有效进制格式表示的字符串值.下面给出几个例子:
var num = 10;
alert(num.toString());//"10"
alert(num.toString(2));//"1010"
alert(num.toString(8));//"12"
alert(num.toString(10));//"10"
alert(num.toString(16));//"a"
通过这个例子可以看出,通过指定基数,toString()方法会改变输出的值.而数值10根据基数的不同,可以在输出时被转换为不同的数值格式.注意,默认的(没有参数的)输出值与指定基数10时的输出值相同.
在不知道要转换的值是不是null和undefined的情况下,还可以使用转型函数String(),这个函数能够将任何类型的值转换为字符串.String()函数遵循下列转换规则:
如果值有toString()方法,则调用该方法(没有参数)并返回相应的结果;
如果值时null,则返回"null";
如果值时undefined,则返回"undefined".
下面再看几个例子:
var value1 = 10;
var value2 = true;
var value3 = null;
var value4;
alert(String(value1));//"10"
alert(String(value2));//"true"
alert(String(value3));//"null"
alert(String(value4));//"undefined"
这里先后转换了4个值: 数值/布尔值/null和undefined.数值和布尔值的转换结果与调用toString()方法得到的结果相同.因为null和undefined没有toString()方法,所以String()函数就返回了这两个值的字面量.
要把某个值转换为字符串,可以使用加号操作符(3.5节讨论)把它与一个字符串("")加在一起.
3.4.7 Object类型
ECMAScript中的对象其实就是一组数据和功能的集合.对象可以通过执行new操作符后跟要创建的对象类型的名称来创建.而创建Object类型的实例并为其添加属性和(或)方法,就可以创建自定义对象,如下所示:
var o = new Object();
这个语法与Java中创建对象的语法相似;但在ECMAScript中,如果不给构造函数传递参数,则可以省略后面的那一对圆括号.也就是说,在像前面这个示例一样不传递参数的情况下,完全可以省略那对圆括号(但这不是推荐的做法):
var o = new Object;//有效,但不推荐省略圆括号
仅仅创建Object的示例并没有什么用处,但关键是要理解一个重要的思想: 即在ECMAScript中(就像Java中的java.lang.Object对象一样)Object类型时所有它的实例的基础.换句话说,Object类型所具有的任何属性和方法也同样存在于更具体的对象中.
Object的每个实例都具备下列属性和方法.
constructor: 保存着用于创建当前对象的函数.对于前面的例子而言,构造函数(constructor)就是Object().
hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中(而不是在示例的原型中)是否存在.其中,作为参数的属性名(propertyName)必须以字符串形式指定(例如: o.hasOwnProperty("name")).
isPrototypeOf(object): 用于检查传入的对象是否传入对象的原型(第5章将讨论原型).
propertyIsEnumerable(propertyName): 用于检查给定的属性是否能够使用for-in语句(本章后面将会讨论)来枚举.与hasOwnProperty()方法一样,作为参数的属性名必须以字符串形式指定.
toLocaleString(): 返回对象的字符串表示,该字符串与执行环境的地区对应.
toString(): 返回对象的字符串表示.
valueOf(): 返回对象的字符串/数值或布尔值白哦是.通常与toString()方法的返回值相同.
由于在ECMAScript中Object时所有对象的基础,因此所有对象都具有这些基本的属性和方法.第5章和第6章详细介绍Object与其他对象的关系.
从基数角度讲,ECMA-262中对象的行为不一定适用于JavaScript中的其他对象.浏览器环境中的对象,比如BOM和DOM中的对象,都属于宿主对象,因为它们时由宿主实现提供和定义的.ECMA-262不负责定义宿主对象,因此宿主对象可能会也可能不会集成Object.
3.5.1 一元操作符
只能操作一个值的操作符叫做一元操作符.一元操作符时ECMAScript中最简单的操作符.
1.递增和递减操作符
递增和递减操作符直接借鉴自C,而且各有两个版本: 前置型和后置型.顾名思义,前置型应该位于要操作的变量之前,而后置型则应该位于要操作的变量之后.因此,在使用前置递增操作符给一个数值加1时,要把两个加号(++)放在这个数值变量前面,如下所示:
var age = 29;
++age;
在这个例子中,前置递增操作符把age的值变成了30(为29加上了1).实际上,执行这个前置递增操作与执行以下操作的效果相同:
var age = 29;
age = age + 1;
执行前置递减操作的方法也类似,结果会从一个数值中减去1.使用前置递减操作符时,要把两个减号(--)放在相应变量的前面,如下所示:
var age = 29;
--age;
这样,age变量的值就减少28(从29中减去了1).
执行前置递增和递减操作时,变量的值都是在语句被求值以前改变的.(在计算机科学领域,这种情况通常被称作副效应.)请看下面这个例子.
var age = 29;
var anotherAge = --age +2;
alert(age);//输出28
alert(anotherAge);//输出30
这个例子中变量anotherAge的初始值等于变量age的值前置递减之后加2.由于先执行了减法操作,age的值变成了28,所以再加上2的结果就是30.
由于前置递增和递减操作与执行语句的优先级相等,因此整个语句会从左至右被求值.再看一个例子:
var num1 = 2;
var num2 = 20;
var num3 = --num1 + num2;//等于21
var num4 = num1 + num2;//等于21
在这里,num3之所以等于21时因为num1先减去了1才与num2相加.而变量num4也等于21时因为相应的加法操作使用了num1减去1之后的值.
后置型递增和递减操作的语法不变(仍然分别是++和--),只不过要放在变量的后面而不是前面.后置递增和递减与前置递增和递减有一个非常重要的区别,即递增和递减操作是在包含它们的语句被求值之后才执行的.这个区别在某些情况下不是什么额外难题,例如:
var age = 29;
age++;
把递增操作符放在变量后面并不会改变语句的结果,因为递增是这条语句的唯一操作.但是,当语句中还包含其他操作时,上述区别就会非常明显了.请看下面的例子:
var num1 = 2;
var num2 = 20;
var num3 = num1-- + num2;//等于22
var num4 = num1 + num2;//等于21
这里仅仅将前置递减改成了后置递减,就立即可以看到差别.在前面使用前置递减的例子中,num3和num4最后都等于21.而在这个例子中,num3等于22,num4等于21.差别的根源在于,这里在计算num3时使用了num1的原始值(2)完成了加法计算,而num4则使用了递减后的值(1).
所有这4个操作符对任何值都使用,也就是它们不仅适用于整数,还可以用于字符串/布尔值/浮点数值和对象.在应用于不同的值时,递增和递减操作符怎寻下列规则.
在应用于一个包含有效数字字符的字符串时,先将转换为数字值,再执行加减1的操作.字符串变量变成数值变量.
在应用于一个不包含有效数字字符的字符串时,将变量的值设置为NaN(第4章将详细讨论).字符串变量变成数值变量.
在应用于布尔值false时,先将其转换为0再执行加减1的操作.布尔值变量变成数值变量.
在应用于布尔值true时,先将其转换为1再执行加减1的操作.布尔值变量变成数值变量.
在应用于浮点数值时,执行加减1的操作.
在应用于对象时,先调用对象的valueOf()方法(第5章将详细讨论)以取得一个可供操作的值.然后对该值应用前述规则.如果结果是NaN,则在调用toString()方法后再应用前述规则.对象变量变成数值变量.
以下示例展示了上面的一些规则:
var s1 = "2";
var s2 = "z";
var b = false;
var f = 1.1;
var o = {
    valueOf: function (){
        return -1;
    }
};
s1++;//值变成数值3
s2++;//值变成NaN
b++;//值变成数值1
f--;//值变成0.10000000000000009(由于浮点舍入错误所致)
o--;//值变成数值-2
2. 一元加和减操作符
绝大多数开发人员对一元加和减操作符都不会陌生,而且这两个ECMAScript操作符的作用与数学书上讲的完全一样.一元加操作符以一个加号(+)表示,放在数值前面,对数值不会产生任何影响,如下面的例子所示:
var num = 25;
num = +num;//仍然是25
不过,再对非数值应用一元加操作符时,该操作符会像Number()转型函数一样对这个值执行转换.换句话说,布尔值false和true将被转换为0和1,字符串值会被按照一组特殊的规则进行解析,而对象时先调用它们的valueOf()和(或)toString()方法,再转换得到的值.
下面的例子展示了对不同数据类型应用一元加操作符的结果:
var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var o = {
    valueOf: function (){
        return -1;
    }
};
s1 = +s1;//值变成数值1
s2 = +s2;//值变成数值1.1
s3 = +s3;//值变成NaN
b = +b;//值变成数值0
f = +f;//值未变,仍然时1.1
o = +o;//值变成数值-1
一元减操作符主要用于表示负数,例如讲1转成-1.下面的例子演示了这个简单的转换过程:
var num = 25;
num = -num;//变成了-25
再将一元减操作符应用于数值时,该值会百年城负数(如上面的例子所示).而当应用于非数值时,一元减操作符遵循与一元加操作符相同的规则,最后再将得到的数值转换为负数,如下面的例子所示:
var s1 = "01";
var s2 = "1.1";
var s3 = "z";
var b = false;
var o = {
    valueOf: function (){
        return -1;
    }
};
s1 = -s1;//值变成了数值-1
s2 = -s2;//值变成了数值-1.1
s3 = -s3;//值变成了NaN
b = -b;//值变成了数值0
f = -f;//变成了-1.1
o = -o;//值变成了数值1
一元加和减操作符主要用于基本的算术运算,也可以像前面示例所展示的一样用于转换数据类型.
3.5.2 位操作符
位操作符用于在最基本的层次上,即按内存中表示数值的位来操作数值.ECMAScript中的所有数值都以IEEE-754 64位格式存储,但位操作符并不是直接操作64位的值.而是先将64位的值转换成32位的整数,然后执行操作,最后再将结果转换回64位的值.而是先将64位的值转换成32位的整数,然后执行操作,最后再将结果转换回64位.对于开发人员来说,由于64位存储格式是透明的,因此整个过程就像是只存在32位的整数一样.
对于有符号的整数,32位中的前31位用于表示整数的值.第32位用于表示数值的符号: 0表示正数,1表示负数.这个表示负号的位叫做符号位,符号位的值决定了其他位数值的格式.其中,正数以纯二进制格式存储,31位中的每一位都表示2的幂.第一位(叫做位0)表示2的0次幂,第二位表示2的1次幂,以此类推.没有用到的位以0填充,即忽略不计.例如,数值18的二进制表示是00000000000000000000000000010010,或者更简洁的10010.这是5个有效位,这5位本身就决定了实际的值.
负数同样以二进制码存储,但是用的格式是二进制补码.计算一个数值的二进制补码,需要经过下列3个步骤:
(1)求这个数值绝对值的二进制码(例如,要求-18的二进制补码,先求18的二进制码);
(2)求二进制反码,即将0替换为1,将1替换位0;
(3)得到的二进制反码加1.
要根据这3个步骤求得-18的二进制码,首先就要求得18的二进制码,即:
0000 0000 0000 0000 0000 0000 0001 0010
然后,求其二进制反码,即0和1互换:
1111 1111 1111 1111 1111 1111 1110 1101
最后,二进制反码加1:
1111 1111 1111 1111 1111 1111 1110 1101
                                      1
1111 1111 1111 1111 1111 1111 1110 1110
这样,就求得了-18的二进制表示,即11111111111111111111111111101110.要注意的是,再处理有负号整数时,是不能访问位31的.
ECMAScript会尽力向我们隐藏所有这些信息.换句话说,在以二进制字符串形式输出一个负数时,我们看到的只是这个负数绝对值的二进制码前面加了一个负号.如下面的例子所示:
var num = -18;
alert(num.toString(2));//"-10010"
要把数值-18转换成二进制字符串时,得到的结果时"-10010".这说明转换过程理解了二进制补码并将其以更合乎逻辑的形式展示了出来.
默认情况下,ECMAScript中的所有整数都是有符号整数.不过,当然也存在无符号整数.对于无符号整数来说,第32位不再表示符号,因为无符号整数只能是正数.而且,无符号整数的值可以更大,因为多出一位不再表示符号,可以用来表示数值.
在ECMAScript中,当对数值应用位操作符时,后台会发生如下转换过程: 64位的数值被转换成32位数值,然后执行位操作,最后再将32位的结果转换回64位数值.这样,表面上看起来就好像是在操作32位数值,就跟在其他语言中以类似方式执行二进制操作一样.但这个转换过程也导致了一个严重的副效应,即在对特殊的NaN和Infinity值应用位操作时,这两个值都会被当成0来处理.
如果对非数值应用位操作符,会先使用Number()函数将该值转换为一个数值(自动完成),然后再应用位操作.得到的结果将是一个数值.
1.按位非(NOT)
按位非操作符由一个波浪线(~)表示,执行按行按位非的结果就是返回数值的反码.按位非是ECMAScript操作符中少数几个与二进制计算有关的操作符之一.下面看一个例子:
var num1 = 25;//二进制 0000 0000 0000 0000 0000 0000 0110 01
var num2 = ~num1;//二进制 1111 1111 1111 1111 1111 1111 1001 10
alert(num2);//-26
这里,对25执行按位非操作,结果得到了-26.这也验证了按位非操作的本质: 操作数的负值减1.因此,下面的代码也能得到相同的结果:
var num1 = 25;
var num2 = -num1 - 1;
alert(num2);//"-26"
虽然以上代码也能返回同样的结果,但由于按位非是在数值表示的最底层执行操作,因此速度最快.
2.按位与(AND)
按位与操作符由一个和号字符(&)表示,它有两个操作符数.从本质上讲,按位与操作就是将两个数值的每一位对齐,然后根据下表中的规则,对相同位置上的两个数执行AND操作:
第一个数值的位          第二个数值的位            结果
      1                      1                   1
      1                      0                   0
      0                      1                   0
      0                      0                   0
简而言之,按位与操作只在连个数值的对应位都是1时才返回1,任何一位时0,结果都是0.
下面看一个对25和3执行按位与操作的例子:
var result = 25 & 3;
alert(result);//1
可见,对25和3执行按位与操作的结果时1.为什么呢?请看其底层操作:
25 = 0000 0000 0000 0000 0000 0000 0001 1001
3  = 0000 0000 0000 0000 0000 0000 0000 0011
AND= 0000 0000 0000 0000 0000 0000 0000 0001
原来,25和3的二进制码对应位上只有一位同时时1,而其他位的结果自然都是0,因此最终结果等于1.
3.按位或(OR)
按位或操作符由一个竖线符号(|)表示,同样也有两个操作数.按位或操作遵循下面这个真值表.
第一个数值的位        第二个数值的位        结果
      1                    1               1
      1                    0               1
      0                    1               1
      0                    0               0
由此可见,按位或操作在有一个位时1的情况下就返回1,而只有在两个位都是0的情况下才返回0.
如果在前面按位与的例子中对25和3执行按位或操作,则代码如下所示:
var result = 25 | 3;
alert(result);//27
25与3按位或的结果时27:
25 = 0000 0000 0000 0000 0000 0000 0001 1001
3  = 0000 0000 0000 0000 0000 0000 0000 0011
OR = 0000 0000 0000 0000 0000 0000 0001 1011
这两个数值的都包含4个1,因此可以把每个1直接放到结果中.二进制码11011等于十进制27.
4.按位异或(XOR)
按位异或操作符由一个插入符号(^)表示,也有两个操作数.以下时按位异或的真值表.
第一个数值的位             第二个数值的位             结果
      1                         1                    0
      1                         0                    1
      0                         1                    1
      0                         0                    0
按位异或与按位或的不同之处在于,这个操作在两个数值对应位上只有一个1时才返回1,如果对应的两位都是1或都是0,则返回0.
对25和3执行按位异或操作的代码如下所示:
var result = 25 ^ 3;
alert(result);//26
25与3按位异或的结果是26,其底层操作如下所示:
25 = 0000 0000 0000 0000 0000 0000 0001 1001
3  = 0000 0000 0000 0000 0000 0000 0000 0011
XOR= 0000 0000 0000 0000 0000 0000 0001 1010
这两个数值都包含4个1,但第一位上则都是1,因此结果的第一位变成了0.而其他位上的1在另一个数值中都没有对应的1,可以直接放到结果中.二进制码11010等于十进制值26(注意这个结果比执行按位或时小1).
5.左移
左移操作符由两个小于号(<<)表示,这个操作符会将数值的所有位向左移动指定的位数.例如,如果将数值2(二进制码为10)向左移动5位,结果就是64(二进制码位1000000),代码如下所示:
var oldValue = 2;//等于二进制的10
var newValue = oldValue << 5;//等于二进制的1000000,十进制的64
注意,在向左移位后,原数值的右侧多出了5个空位.左移操作会以0来填充这些空位,以便得到的结果时一个完整的32位二进制数(见图3-2).
注意,左移不会影响操作数的符号位.换句话说,如果将-2向左移动5位,结果将是-64,而非64.
6.有符号的右移
有符号的右移操作符由两个大于号(>>)表示,这个操作符会将数值向右移动,但保留符号位(即正负号标记).有符号的右移操作与左移操作恰好相反,即如果将64向右移动5位,结果将变回2:
var oldValue = 64;//等于二进制的1000000
var newValue = oldValue >> 5;//等于二进制的10,即十进制的2
同样,在移位过程中,原数值中也会出现空位.只不过这次的空位出现在原数值的左侧/符号位的右侧(见图3-3).而此时ECMAScript会用符号位的值来填充所有空位,以便得到一个完整的值.
7.无符号右移
无符号右移操作符由3个大于号(>>>表示,这个操作符会将数值的所有32位都向右移动.对正数来说,无符号右移的结果与有符号右移相同.仍以前面有符号右移的代码为例,如果将64无符号右移5位,结果仍然还是2:
var oldValue = 64;//等于二进制的1000000
var newValue = oldValue >>> 5;//等于二进制的10,即十进制的2
但是对负数来说,情况就不一样了.首先,无符号右移时以0来填充空位,而不是像有符号右移那样以符号位的值来填充空位.所以,对正数的无符号右移与有符号右移结果相同,但对负数的结果就不一样了.其次,无符号右移操作符会把负数的二进制码当成正数的二进制码.而且由于负数以其绝对值的二进制补码形式表示,因此就会导致无符号右移后的结果非常之大,如下面的例子所示:
var oldValue = -64;//等于二进制的1111 1111 1111 1111 1111 1111 1100 0000
var newValue = oldValue >>> 5;//等于十进制的134217726
这里,当对-64执行无符号右移5位的操作后,得到的结果是134217726.之所以结果如此之大,是因为-64的二进制码为1111 1111 1111 1111 1111 1111 1100 0000,而且无符号右移操作会把这个二进制码当成正数的二进制码,换算成十进制就是4294967232.如果把这个值右移5位,结果就变成了0000 0111 1111 1111 1111 1111 1111 1110,即134217726.
3.5.3 布尔操作符
在一门编程语言中,布尔操作符的重要性堪比相等操作符.如果没有测试两个值关系的能力,那么诸如if...else和循环之类的语句就不会有用于之地了.布尔操作符一共有3个:非(NOT)/与(AND)和或(OR).
1.逻辑非
逻辑非操作符由一个叹号(!)表示,可以应用于ECMAScript中的任何值.无论这个值是什么数据类型,这个操作符都会返回一个布尔值.逻辑非操作符首先会将它的操作数转换为一个布尔值,然后再对其求反.也就是说,逻辑非操作符遵循下面规则:
如果操作数是一个对象,返回false;
如果操作数是一个空字符串,返回true;
如果操作数是一个非空字符串,返回false;
如果操作数是数值0,返回true;
如果操作数是任意非0数值(包括Infinity),返回false;
如果操作数是null,返回true;
如果操作数是undefined,返回true.
下面几个例子展示了应用上述规则的结果:
alert(!false);//true
alert(!"blue");//false
alert(!0);//true
alert(!NaN);//true
alert(!"");//true
alert(!12345);//false
逻辑非操作符也可以用于将一个值转换





























































