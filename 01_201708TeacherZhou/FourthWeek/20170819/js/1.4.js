
// //-----------------------------------------------定时器的同步编程
// //->范例一: 定时器是1000ms
// var n = 0;
// window.setTimeout(function () {
//     console.log(++n);//->第二个输出: 1
// },1000);
// clearInterval(n);//->先输出,0


// //-----------------------------------------------setTimeout鉴证浏览器的最小反应时间
// //->范例一: 定时器是0ms
// //->定时器的等待时间设置为零也不是立即执行: 浏览器在处理一件事情的时候,会有一个最小的反应时间,我们写零浏览器是反应不过来的(谷歌一般最小的反应时间是5~6ms,IE是10-13ms,这个值会根据当前电脑cpu性能能来决定的,每个人的不太一样)
// var n = 0;
// window.setTimeout(function () {
//     console.log(++n);//->第二个输出: 1
// },0);//->5~6
// clearInterval(n);//->先输出,0



// //------------------------------------------onscroll鉴证浏览器的最小反应时间
// window.onscroll = function () {
//     //->通过 onscroll 也可以鉴证浏览器是有自己的处理最小反应时间的,我们快速滑动,在短时间那日触发的此处就少一些,慢一些滑动,滑动相同的距离用的时间就会多一些,触发次数也会多一些;
//     console.log("ok");
// };


// //----------------------------------------------- for循环 "检测代码执行的性能"
// var strTime=new Date();
// for(var i=0;i<1000000000;i++){
//     //->循环10亿次
// }
// var endTime=new Date();
// console.log(endTime - strTime);//->大约需要3268ms(通过这种方式可以检测代码执行的性能)


// //-----------------------------------------------定时器的等待时间的先后顺序: 时间到了不一定执行
// //->定时器设定了等待时间,到达时间后也不一定执行,看当前主任务队列中是否有任务正在执行呢,如果有任务在执行,到时间后也依然需要继续等待(JS是单线程的)
// var n = 0;
// window.setTimeout(function () {
//     console.log(++n);//->2)1
// },0);
// for(var i=0;i<1000000000;i++){
//     //->循环10亿次
// }
// console.log(n);//->1)0





// //-----------------------------------------------定时器的while循环: 死循环
// //->此时的队列中遇到了死循环,浏览器永远空闲下不下来,定时器等不到执行的那一天了(真实项目中要杜绝出现死循环: 出现死循环什么就做不了了);
// var n = 0;
// window.setTimeout(function () {
//     console.log(++n);
// },0);
// while(1==1){
//     //->死循环
// }


//-----------------------------------------------定时器的执行顺序: 多条任务同时到时间
//->当主任务队列的任务完成后,会到等待任务队列中,把到时间的任务执行;如果好多任务都到时间了,谁先到的,我们先执行谁;如果时间都很短,而且很相近,有些时候浏览器执行顺序混乱(可以理解为浏览器的bug)
window.setTimeout(function () {
    console.log(1);//->第3次打印
},100);

window.setTimeout(function () {
    console.log(2);//->第1次打印
},0);


window.setTimeout(function () {
    console.log(3);//->第2次打印
},50);
for (var i = 0; i < 1000000000; i++) {
    //->循环10亿次: 需要大概3-4s,上面所有的定时器都到时间了
}



// //-----------------------------------------------事件绑定
// //->所有的事件绑定也都是异步编程;
// oImg.onload = function(){
//     //->当图片加载成功后执行这个匿名函数
//     alert("img is load success~");//->如果成功,第2次打印这个
// };
// oImg.onload = function(){
//     //->当图片加载失败后执行这个匿名函数
//     alert("img is load error~");//->如果失败,第2次打印这个
// };
// alert("img is loading~");//->第1次打印






// //-----------------------------------------------AJAX
// //->AJAX中也可以设置异步编程
// var xhr = new XMLHttpRequest;
// xhr.open("GET","地址",false);//->写false: 同步;  不写或者写true: 异步;














