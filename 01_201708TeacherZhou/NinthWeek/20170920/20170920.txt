一.客户端向服务器端发送请求,分为两大阶段:
    1.request(请求阶段): 客户端向服务器端发送请求;
    2.response(响应阶段): 服务器端把客户端需要的信息返回;
    两个阶段都可能会有数据和内容的传输: 客户端可以发送一些信息给服务器,服务器也会把一些信息返回给客户端;

    传输协议: 用来传递客户端和服务器端交互信息的;
    传输协议分类:
        1.http: 常用的传输协议中的一种;超文本传输协议;(不仅仅能传递文本,还可以传递图片,音频,视频等资源的文件流以及xml文档流);
        2.https: 更加安全的http.因为它开启了SSL通道(传输的内容是经过SSL加密的);一般需要支付的网站都需要使用https协议;
        3.FTP: 也是常用的协议;文件上传下载的协议;

    域名
        域名: 给服务器外网IP地址起一个好记的名字;
        http://www.zhufengpeixun.cn/student/index.html?name=sh&age=18#pay
        一级域名: www.qq.com
        二级域名: sports.qq.com
        三级域名: kbs.sports.qq.com

        二三级域名是不需要购买,是基于当前域自定义;

        .com: 国际域名(商业组织或者公司)
        .cn: 中国顶级域名(商业组织或者公司)
        .net: 网络服务商(还有办公系统类的产品一般会用这种域名)
        .org: 机构组织域名(非盈利的)
        .gov: 政府官方域名
        .edu: 教育院校域名
        ...

    端口号:
        端口号: 在同一台服务器上区分不同的服务以及项目,我们使用不同的端口号即可;
        同一台服务器的端口号取值范围: 0-65535;
        我们在电脑上安装的一些软件,大部分都会占用一下当前电脑的某个端口号;例如: QQ...(服务器上不允许安装任何软件,就是避免一些端口被占用...服务器是要求纯净的服务器)
        平时上网我们不需要手动输入端口号,不同的传输协议都有自己默认的端口号;(我们自己不写,浏览器会主动为我们增加上对应的端口号)
        http对应的默认端口号是80;https对应的默认端口号是81;ftp对应的默认端口号是21;

    请求资源文件的路径名称
        /student/index.html
        请求当前项目文件中student文件中的index.html页面,但是需要注意的是: 当前URL可能是伪造的;仅是为了增加SEO的收录和抓取;

    问号传参
        ?name=sh&age=18
        在URL问号后面传递的值统称为问号传参;格式: 属性名=属性值&属性名=属性值  多个用&符号隔开;
        问号传参的作用: 1.客户端可以通过问号传参的方式把一些数据和内容传递给服务器;服务器接收到内容后可以做相关处理;2.用于两个页面之间的数据传输;例如: 列表页中有很多数据,点击每一条数据都可以跳转到详情页面(详情页是一个);但是需要在同一个详情页展示不同的信息(列表页点击的是哪一个就展示谁的信息);如何处理?--我们在点击跳转的时候,把点击的信息通过问号传递方式传递给详情页面,进入到详情页面后,首先获取地址栏中问号传递的参数值;
        http://www.zhufengpeixun.cn/student/index.html?name=sh&age=18#pay


    HASH值
        HASH(哈希)值: 在一个URL中#后面的值被成为哈希值;#pay
        HASH值的作用:
            1.也可以通过这种方式把数据传递给服务器端或者传递给另外一个页面(类似于问号传参: 这种模式不常用)
            2.锚点定位
            3.前端路由
            http://www.zhufengpeixun.cn/student/index.html?name=sh&age=18#pay

    URI/URL/URN
        http://www.zhufengpeixun.cn/student/index.html?name=sh&age=18#pay
        URI: 统一资源标识符
        URL: 统一资源定位符
        URN: 统一资源名称;

        关系:
            URI = URL + URN


二.前端优化的一些方法和建议

    一.减少HTTP的请求次数
        1.CSS SPRITES: 雪碧图,把图片压缩合并在一张大图上,背景图片统一导入大图,使用background-position定位到具体的小图;
            把导入大图提取为公共的样式,只写一次导入,结构中需要的话,增加这个样式类即可;
            举例
            .bg-img{
                background: url("大图地址") no-repeat;
            }
            .box1{
                background-position: xxx xxx;
            }
            .box2{
                background-position: xxx xxx;
            }

            <div class="bg-img box1"></div>
            <div class="bg-img box2"></div>

        2.把CSS合并成为一个,把JS也合并为一个,减少CSS以及JS等文件的请求次数(真实项目中,我们使用gulp,webpack这些自动化工具,可以完成合并压缩);

        3.在移动端开发中,如果页面中的CSS和JS"不是很多的话",尽量使用内嵌式,以此减少HTTP请求次数;

        4.图片的base64;(图片的码放进去,但!慎用!!)我们在webpack中可以统一设置一下,把多大范围内的图片都base64了;

        5.把不需要经常更新的数据或者资源,进行304缓存或者进行本地存储,减少在一定时间内重复向服务器发送HTTP请求(在此阶段内,我们只需要读取缓存和本地数据即可);但是有个时间段限制的,不可能无循环;

        6.为了加快页面首次打开速度,我们把图片和数据都做一下延迟加载;数据的延迟加载: 滚动到底部加载更多数据;还有分页效果也是延迟加载;

        7.音视频等资源文件开始的时候设置preload="none",也就是开始加载页面不加载资源文件,只有当播放的时候再加载音视频的播放;


    二.减少请求资源文件的大小
        1.图片资源,JS/CSS文件资源都要进行压缩: 图片压缩的前提,是保证图片不失真;(使用googole的gif压缩);

        2.减少每一次AJAX请求数量的大小,对于很多大数据我们尽量分多次请求;

        3.开启服务器的GZIP压缩,不仅把文件给压缩了,而且传输的数据和内容也是经过压缩的(这个操作由服务器人员来完成);

        4.减少页面中的冗余代码,提高代码的重复利用率,例如: JS中的函数封装,CSS中公共样式提取等;

        5.在项目中如果使用框架或者类库,需要允许的情况下,尽量使用轻量级的(尤其是移动端开发)

        6.对于图片等资源的交互传输,我们尽量把图片等富媒体资源转换为二进制编码,使用二进制文件流的形式传输,不仅加快了文件传输的速度,也节省了传输的大小;


    三.CSS代码优化
        1.外链式导入CSS样式表,我们使用link代替@import,@import是同步导入,当前资源文件没有加载完成,下面的CSS不会执行;

        2.把CSS放在页面的头部,优先加载和渲染;JS放在底部,等待子u后再加载渲染;

        3.能够使用CSS解决的,绝对不使用FLASH

        4.避免使用CSS表达式

        5.少使用filter滤镜: IE低版本浏览器中，filter会阻止图片的渲染，使用滤镜销毁的性能较大

        6、尽量使用transform变形来代替传统css样式的改变，因为transform开启了硬件加速，性能流畅一些

        7、修改元素的样式尽量使修改样式类名，少使用style修改

        8、css中尽量多使用样式类选择器，少使用通配符或者标签选择器；少使用单规则属性选择器等；（因为css选择器是从右向左进行匹配的）

            .box a{}
            先找到所有的a标签，然后再匹配筛选在.box下的a

            .box .link{}
            先找到所有样式类为link的（这样肯定比使用标签名找到的少很多）

            a[href='xxx'] 先找到所有的href，然后属性值为xxx，再向上匹配它的元素

        9、避免深层次的节点嵌套

            雅虎优化的35条建议：自己总结更多的css代码优化技巧


    四.js代码优化
        1、减少闭包的使用（闭包会产生不销毁的作用域，占用了浏览器很多的内存）

        2、一定要养成手动释放堆栈内存的习惯，经常去清空一些没有用处的内存（例如：手动清除没用的定时器、把一些无用的对象赋值为null...）

        3、避免内存互相引用嵌套导致的内存泄漏问题（高程三后面有关于内存泄漏的讲解）

        4、不要使用with，少使用eval，少使用document.write以及alert等（页面中的提示框，我们可以自己编写一个组件来完成）

        5、注意DOM的回流重载问题

        6、少使用同步编程，多用异步编程，注意页面中不要出现死循环

        7、减少浏览器的异常信息抛出，最好使用try catch把它捕获了

        8、少使用全局变量，依托单例、发布订阅、promise等设计模式，来规划我们的代码结构，保证代码的严谨和有利于维护

        9、事件绑定尽量使用事件委托来处理

        10、减少作用域链的查找（作用域之间不要嵌套太深）

        11、优化js代码逻辑，用最简单的方式来实现一个功能需求，一些没必要的判断或者没必要执行的代码都让其不执行即可（一些编程的好习惯）

        12、为了保证安全，一些重要的数据信息在进行交互的时候要进行加密，而且传输方式尽量使用post方式，get请求不安全

        13、前后端的数据交互，数据格式最好是json格式的：结构清晰明了，处理起来方便，传输性能也比较的不错...


    五.有助于SEO优化推广的
        1、设置合理的title、keywords、description等信息

        2、标签语义化

        3、增加页面中关键词的曝光率，把一些重要的关键词多放在权重较高的标签中（例如：h1中有图片和文字，文字是给百度爬虫看的， 图片是给用户看的 ）

        4、img设置alt属性，

        5、页面中千万不要出现死链接和空链接

        6、避免页面301和302重定向，重定向不太利于网站权重和排名的上升

        7、动态页面静态化（伪url重写）

        8、页面中尽量不要使用iframe，不仅不利于SEO优化，而且性能也会受到影响


    六.其它优化
        1、后台优化：一个网站性能优化前端是次要的，后台优化（尤其是数据分析挖掘的优化）比前端重要很多，后台优化可以把页面加载速度提高很多

        2、服务器优化：不管前后端怎么优化，页面整体加载速度只会提升，但是不会特别的明显，尤其是访问人数过多的时候，此时服务器优化很重要：
            - 加服务器
            - CDN地域分布式


三.NODE.JS
    node.js是基于v8引擎运行js的环境,它不是一门语言,你可以把它理解为谷歌浏览器,它是工具;node是后台语言(这样称呼是不对的);node是安装在服务器上;
    那为什么还有人把node叫后台编程语言?
        先理解什么是node;
        客户端向服务器端发送请求,服务器端需要编写程序,把客户端请求的内容准备好,返回给客户端;

        我们可以使用java,php...等语言编写程序,也同样可以使用js编写程序(js是全栈编程语言,它不仅仅写客户端的程序,还可以写后台的程序);

        js代码写完后,我们把它运行,此时我们在服务器上安装一个node工具,使用node工具可以把这些代码执行,从而让其具备相关的功能即可;

        让代码运行,都要有一个语言所熟悉的环境;

四.安装node
    http://nodejs.cn/  中文网
    https://nodejs.org/en/   英文网

    安装的时候,基本上一路下一步即可;node安装成功后,会把相关的操作命令集成在系统的dos命令中;(MAC是终端),以后我们可以在DOS(终端)命令中执行node的命令;

五.检查node是否安装成功
    cmd
    执行命令: node -v
    出现版本号,代表安装成功;

六.node.js组成的基础知识
    基于node环境使用js编写后台程序,相对于传统的后台语言具备了一些优势:
        1.基于v8引擎来渲染解析代码;---快!
        2.基于事件驱动的非阻塞I/O操作;
        3.采用的是异步单县城开发;
        4.node中的npm包管理器是全球最大的开源库生态系统;
            http://www.npmjs.com
        5.对于前端开发工程师来说,学习成本低,可以快速入手这门技术;

七.NODE中的模块
    node其实就是由很多模块拼起来的(node中单独的部分就叫模块);模块中分为: 1.内置模块;2.自定义模块;3.第三方模块;
        内置模块: node环境本身自带的;类似于浏览器天生自带一些自己的方法;
        自定义模块: 开发者自己编写的
        第三方模块: 别人写好的模块,我们可以下载使用(类似于在客户端导入的jQuery.js);所有我们使用的第三方模块,在npmjs.com中都可以获取到;而模块的下载安装统一使用npm包管理器完成;

八.第三方模块(npm)
    npm中有less模块->下载->安装模块->执行两个命令:
    1.npm install xxx -g   把模块安装在全局环境下;
    npm install --global xxx  也可以这样写;   顺便提一句: 浏览器中的全局对象是window;node中的全局对象是global;

    2.npm install xxx  把模块安装在当前操作的项目目录下
    npm intall xxx --save-dev  不仅安装在当前项目目录下,并且把安装信息记录在项目的package.json清单中,生成一条"开发环境依赖项";
    npm intall xxx --save  和上述操作类似,不过生成的是一条"生产环境依赖项";

    npm指定安装模块的某个版本
    npm install jquery@1.11.3  在安装这个模块的时候,指定了安装模块的版本号;

    npm卸载模块
    3.npm uninstall xxx -g/--save-dev/--save  相对于安装来说,当前操作是卸载这些模块;


九.npm安装模块的时候,安装在全局和安装在本地项目中的区别
    1.安装在全局,可以使用命令,无法使用导入(批量操作文件);
    2.安装在本地,能拿代码导入,但无法使用命令;
    实现既能使用命令,又能导入;解决方法: 依然是安装在项目中,在本地项目中配置的运行命令;npm init -y

        安装在全局
            安装在全局下,会在安装的全局目录中生成一个文件:
            lessc.cmd ->可以在DOS中执行命令的文件,此时我们就可以在DOS中执行lessc这个命令了;
            安装在全局环境下的模块可以使用命令来操作;但是只能使用命令操作;如果想把这个安装的模块导入到我们自己JS代码中使用,则是不可以的;
            安装在全局下可以使用lessc命令,执行lessc xxx.less xxx.css只能编译一个文件;批量编译多个文件的时候,需要导入进来,这时候就需要安装在项目中;

        安装在本地项目中
            加-g,安装在全局;不加-g就是安装在项目中
            执行安装命令:
            npm install less

            安装完成后在当前的项目目录下多了一个文件node_modules;此文件夹中包含了我们安装的less模块;相当于把less模块安装在当前项目中;
            安装在本地项目中的模块不能使用命令来操作(默认情况下);但是可以在当前项目的JS代码中,通过require把它导入进来;然后在JS代码中调取模块中的方法,实现一些特殊的处理,如下:

        尝试用代码解决批量的问题
        let aa=require("less");
        console.log(aa);//->能导入进来使用
        aa.render();//->


十.能否有办法既能使用命令也能导入到JS中?
    真实项目开发的时候,我们很少安装在全局,因为安装在全局可能导致版本的冲突,一般我们都安装在本地项目中;

    在本地项目中配置模块的运行命令
    第一步: 执行命令 npm init -y      所有一路都是yes
        在本地项目文件中,生成了一个文件package.json
        package.json: 模块的配置清单(项目模块配置文件);(命令当中不加-y,在执行命令的时候,需要自己一个个的配置信息;加-y一切都走默认配置);
            package.json解析
                name: 项目名称
                version: 项目版本
                description: 项目的描述
                main: 项目的入口页面(首页面)
                dependencies: 生产环境依赖模块清单
                devDependencies: 开发模块依赖环境清单
                scripts: 项目的命令脚本配置
                keywords: 关键词
                author: 作者
                license: 监听模式

            一个模块称之为一个项目;一个项目可以称之为大模块;

    第二步: 配置scripts属性
        在生成的package.json文件中的scripts属性中,配置我们需要运行的命令:
        怎样配置scripts?清除默认值,写入以下:
            "lessc属性名自定义": "lessc less/index.less css/index.min.css -x 属性值是即将执行的命令"

    第三步: 执行命令npm run lessc
        配置完成后,在当前项目的DOS命令中执行npm run lessc(自定义属性名)  完成编译;
        执行npm run lessc的时候,相当于把lessc的属性值,在DOS命令中执行了,而属性值就是把某个less编译成css的命令;


    总结:
        1.本地项目中安装less模块  npm install less
        2.配置本地模块的运行命令   npm init -y
        3.在生成的package.json文件中,配置scripts属性    "lessc属性名自定义": "lessc less/index.less css/index.min.css -x 属性值是即将执行的命令"
        4.在DOS中执行命令 npm run lessc


生产环境和开发环境
    1.dependencies: 生产环境依赖模块清单
        生产环境: 项目开发完成部署到服务器上,所需要依赖的模块叫做生产环境依赖项;

    2.devDependencies: 开发模块依赖环境清单
        开发环境: 项目在本地开发的时候,所需要依赖的模块叫做开发依赖项;

    举例:
        less模块,开发的时候需要依赖,项目部署后不需要依赖;开发的时候需要安装less模块,项目上线则不需要安装less模块;

        npm install less --save  安装less模块并把安装的信息存放在生产依赖项中

        npm install less --save-dev  安装less模块并把安装的信息存放在开发依赖项中

        npm install babel-cli --save-dev 安装babel模块并把信息保存在开发依赖项中

        npm install jquery --save-dev --save      安装jQuery模块并把信息保存在开发依赖项中

    为啥要设置依赖项?
        1.项目如果是多人开发,我们使用git仓库来管理项目代码以及实现团队协作开发;
        2.A是其中的开发人员,开发这个项目需要用到很多模块,A在自己的电脑上把需要的模块都安装在本地项目的node_modules文件夹中了(A开发所用的东西都有了);
            A在提交自己的代码到git仓库的时候,会忽略node_modules文件夹的提交,因为这个文件夹的内容太大了;
                (禁止忽略这个文件的提交的方法: 当前项目中增加.gitignore文件,在.gitignore中把这个文件写上即可)
            B开发人员从git仓库下载代码,代码都有了,但是开发需要依赖的模块没有;(没有模块,就不能把项目跑起来),此时B人员也需要安装这些模块;

        有两种方式可以让项目跑起来:

            1.找到A人员手动记录一下安装的模块,然后自己在本地一个个的安装(这个方法不可行,太慢太low);

            2.下载完项目,执行npm install
                此时体现出我们配置依赖项的好处,A人员在本地安装的时候,把安装的信息都记录在package.json的devDependencies/dependencies这里面,虽然node_modules没有传递到git仓库中,但是package.json传递上传了;B人员把项目下载完成后,在本地的package.json中可以看到需要依赖的模块信息,此时B人员只需执行命令: npm install 命令;就可以把当前项目需要依赖的模块自动的都安装上了,我们把这个操作叫做"跑环境";

                跑完环境之后,npm run lessc(scripts的属性名),生成一个8080的端口;

                    项目上线也是同样的原理;



node.js从nodejs.com下载

bower
    从gitHub社区下载


任务:
    新建一个项目,安装babel;


预习视频:
    课件8: 静态资源文件











































