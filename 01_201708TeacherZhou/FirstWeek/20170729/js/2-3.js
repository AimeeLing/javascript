/**
 * 结果报错!
 * 全局下的变量提升:
 *      f = xxxfff000    空间地址
 *      g = xxxfff111  空间地址
 *
 *      匿名函数之自执行函数: 函数的创建和执行一起完成了;
 *
 *      自执行函数,也是普通函数;要经历函数的五步骤;
 *      自执行函数,也是普通函数;要经历函数的五步骤;
 *      自执行函数,也是普通函数;要经历函数的五步骤;
 *      自执行函数,也是普通函数;要经历函数的五步骤;
 *      自执行函数,也是普通函数;要经历函数的五步骤;
 *      自执行函数的上级作用域是啥就是啥;
 *      自执行函数的上级作用域是啥就是啥;
 *      自执行函数的上级作用域是啥就是啥;
 *      自执行函数的上级作用域是啥就是啥;
 *      自执行函数的上级作用域是啥就是啥;
 *      自执行函数在当前作用域下不参与变量提升,只有在执行的时候当作普通函数进行变量提升;
 *      自执行函数在当前作用域下不参与变量提升,只有在执行的时候当作普通函数进行变量提升;
 *      自执行函数在当前作用域下不参与变量提升,只有在执行的时候当作普通函数进行变量提升;
 *      自执行函数在当前作用域下不参与变量提升,只有在执行的时候当作普通函数进行变量提升;
 *      自执行函数在当前作用域下不参与变量提升,只有在执行的时候当作普通函数进行变量提升;
 * @returns {boolean}
 */


/*function f() {return true;}
function g() {return false;}
~function () {
    /!*
     * 自执行函数执行,形成一个私有的作用域
     *       形参赋值
     *       变量提升: function g;  不管条件是否成立都要提升,但是提升的时候只是声明不定义了;
     * *!/
    if (g() && ([] == ![])) {//->g() =>undefined() ->报错: g is not a function;
        f = function () { return false;};//->等号右边是值,是不进行变量提升的
        function g() {
            return true;
        }
    }
}();
console.log(f());
console.log(g());*/


//----------------------------------------------------------------------
//匿名函数之自执行函数: 函数的创建和执行一起完成了;
(function () {//->前面加分号: 防止上面的函数创建完成;后面不加分号,以后代码压缩成衣阿华给你的时候,让自执行函数成为上面函数的执行参数;
    console.log("ok");
})();

// ~function () {
//
// }();
// !function () {//遇到叹号不是取反,仅仅是为了符合语法而已;
//
// }();
// +function () {
//
// }();
// -function () {
//
// }();

//----------------------------------------------------------------------

function f() {return true;}
function g() {return false;}
~function () {

    if (g() && ([] == ![])) {
        f = function () { return false;};
    }
    function g() {return true;}
}();
console.log(f());//->false    自执行函数内把f的值改成了false
console.log(g());//->false   window.g = false;




























