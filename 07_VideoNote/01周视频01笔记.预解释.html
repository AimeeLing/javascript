<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>

    //JS中的数据类型;
    //基本数据类型
    //number,string,boolean,null,undefined

    //引用数据类型
    //object : {},[],/^$/,Date
    //function

    /*var num = 12;//number数据类型
    var obj = {name:'珠峰培训',age:7};//对象数据类型
    function fn(){//函数数据类型
        console.log('勿忘初心方得始终');
    }
    console.log(fn);//把整个函数的定义部分(函数本身)在控制台输出
    console.log(fn());//把当前函数执行的返回结果(return后面写的是啥,返回值就是啥,如果没有return,默认返回值是undefined)*/

    //1. 当浏览器加载HTML页面的时候，首先会提供一个供全局JS代码执行的环境　－＞全局作用域（后台用global表示，在前端用window代表）


    //2. 预解释(变量提声)
    // 在当前的作用域当中,JS代码执行之前,浏览器首先会默认的把素有带var和function的进行提前声明[或者]定义;
    //1) 理解声明和定义
    //var num = 12;
    //声明(declare): var num;=>告诉浏览器在全局作用域中有一个num的变量了;=>如果一个变量只是声明了但是没有赋值,默认的值是undefined;
    //定义(defined): num = 12; =>给我们的变量进行赋值;

    //2) 对于带var和带function关键字的在预解释的时候操作还是不一样的
    //var =>在预解释的时候只是提前的声明;
    //function =>在预解释的时候提前的声明 + 定义 都完成了;


    //3) 预解释只发生在当前的作用域下,例如:开始只对window下的进行预解释,只有[函数执行的时候]才会对函数中的进行预解释;

    console.log(num);//undefined  因为在执行之前,var num;已经声明了;所以结果是undefined,而不是报错;
    var num = 12;
    var obj = {name:'珠峰培训',age:7};
    console.log(num);//12
    fn(100,200);//300  实现了求和;  fn()执行可以在函数上面执行,因为预解释的时候声明+定义就已经完成了;
    function fn(num1,num2){
        var total = num1+num2;
        console.log(total);
    }

    //3. JS中内存的分类
    //栈内存:用来提供一个供JS代码执行的环境 =>作用域: JS当中的作用域有两种 =>1.window全局作用域;2.私有作用域;
    //堆内存: 用来存储引用数据类型的值 =>对象存储的是属性名和属性值,函数存储的是代码字符串...;

    //预解释发展在栈内存当中;




</script>
</body>
</html>